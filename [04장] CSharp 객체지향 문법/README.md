# 4장 C# 객체지향 문법

## 클래스

- C#에서 타입을 정의하는 예약어 : `class`
- 생성자
    - 클래스에 생성자 메소드를 추가하면 객체가 생성되는 시점에 해당 메서드가 자동으로 호출
    - `new`를 실행하면 언제나 해당 객체의 생성자가 함께 실행
- 소멸자
    
    ```csharp
    class 클래스_명
    {
    	~클래스_명()
    	{
    		//실행
    	}
    }
    ```
    
    - 객체가 제거되는 시점에 실행
    - 소멸자는 이름이 `~` 접두사로 쓰는 클래스명과 동일 + 인자나 반환값 X
    - 실행되는 시점은 예측 불가
    - C#는 사용자가 객체를 의도적으로 제거하는 기능이 없지만 CLR에서 내부적으로 GC
        - 모든 참조형 변수를 생성할 때 GC가 관여
        - GC는 요청된 변수의 타입이 요구하는 메모리를 힙에 할당 후 스스로 적절하다고 판단되는 시점에 힙 청소
        - 객체가 더는 사용되고 있지 않다면 객체의 데이터 해제
    - C#의 참조형 변수가 가리키는 객체는 GC가 호출돼야 소멸자가 호출
    - 닷넷이 관리하지 않는 시스템 자원을 얻은 경우에만 소멸자를 정의해야 함

## 정적 필드 : 싱글턴 클래스

- 인스턴스가 단 하나만 존재하는 타입 = 싱글톤
    - 단일 시스템 자원을 책임지는 타입이 필요할 때 싱글턴 클래스만들어 다른 클래스에 기능을 노출하는 용도
- `Main`메서드
    - CPU에 의해 프로그램은 순차적으로 실행되는데 진입점이 최초로 실행될 메서드
    1. 메서드 이름 반드시 `Main`
    2. 정적 메서드
    3. `Main`메서드가 정의된 클래스의 이름은 제한이 없지만 2개 이상의 클래스에서 `Main`정의시  C# 컴파일러에게 클래스를 지정
    4. `Main`메서드의 반환값 → `void` `null`
        - 반환값은 EXE 프로그램의 실행 결과에 대한 오류 여부를 판단
    5. `Main`메서드의 매개변수는 없거나 `string`배열만 허용
    - 이 규칙을 만족하는 메서드 정의 → C# 컴파일러는 자동으로 그 메서드를 시작점으로 선택해 EXE 파일 생성
- 정적 생성자
    - 기본 생성자에 `static` 예약어를 붙인 경우
    - 클래스에 단 한개만 존재할 수 있고 매개변수를 포함할 수 없음
    - 주로 정적 멤버를 초기화하는 기능을 하기 위함 = 형식 이니셜라이저
    - C# 컴파일러는 정적 필드를 초기화하는 코드를 자동으로 정적 생성자로 옮겨서 컴파일
        
        → 정적 필드를 사용하면 내부적으로 정적 생성자를 사용
        
    - C# 컴파일러는 사용자가 정의한 정적 생성자의 코드와 초기화 코드를 자동으로 병합해 정의하기에 정적 필드가 초기화 되어 있어도 상관 X
    - 정적 생성자는 클래스의 어떤 멤버든 최초로 접근하는 시점에 단 한 번만 실행

## 네임스페이스

- 말 그대로 이름 공간으로 수 많은 클래스를 분류하는 방법으로 사용
- C#의 `using`예약어를 사용해 네임 스페이스를 미리 선언해두면 객체를 생성할 때 C# 컴파일러가 알아서 객체가 속한 네임스페이스를 찾아내어 오류 없이 컴파일
- FQDN(Fully Qualified Domain Name) : 네임스페이스가 생략된 클래스명과 구분해 클래스명에 네임스페이스까지 함께 지정하는 경우

## 캡슐화

- 관련성 있는 데이터와 그 데이터를 다루는 메서드를 객체 안에 구현하는 것이 일반적
- 객체의 밖에서 알아야 할 필요가 없는 내부 멤버를 숨길때 캡슐화 한다고 표현

## 접근 제한자

- `private`: 내부에서 접근을 허용
- `protected`: 내부에서 접근과 함께 파생 클래스에서만 접근 허용
- `public`: 내부 및 파생 클래스에서의 접근뿐만 아니라 외부에서도 접근을 허용
- `interanl`: 동일한 어셈블리 내에서만 접근 가능
- `internal protected` : 동일 어셈블리 내에서 정의된 파생 클래스까지만 접근 허용
    - `protected interanl`도 가능
- `class`정의에서 접근 제한자 생략한 경우 : `internal`
- `clas` 내부의 멤버에서 접근 제한자 생략한 경우 : `private`

## 정보 은닉

- 외부에서 멤버 변수를 직접 접근할 수 없게 만드는 것
- 접근자/설정자 메서드가 나오게 된 이유 중 하나는 코드에 대한 유지보수를 쉽게 하기 위해서
- 정보 은닉 원칙
    - 특별한 이유를 제외하고는 필드를 절대 `public` 으로 선언하지 않는다
    - 접근이 필요할 때는 접근자/설정자 메서드를 만들어 외부에서 접근하는 경로를 클래스 개발자의 관리하에 둔다.

## 프로퍼티

- 접근자/설정자 메서드를 프로퍼티문법으로 제공 → 도우미 성격의 구문
    
    ```csharp
    class Circle
    {
    	public double PI 
    	{
    		get{return PI;}
    		set{PI=value;}
    	}
    }
    ```
    
    - 설정자 메서드 : 사용자가 전달하는 값을 매개변수명으로 구분 가능
    - 접근자 메서드 : 별도로 `set` 블록 내부에서만 사용할 수 있는 `value` 예약어 존재
    - C# 컴파일러가 빌드하는 시점에서 자동으로 메서드로 분리
        1. `set` 프로퍼티 없애기
        2. `get`, `set` 프로터피 높고 `private` 선언

## 상속

- C#에서는 클론을 이용해 부모 클래스의 기능을 물려받음
    
    ```csharp
    public class NoteBook : Computer
    {
    	// 코드코드
    }
    ```
    
- 상속받은 클래스는 부모의 속성과 행위를 접근 제한자 규칙에 따라 외부에 제공
- 상속을 의도적으로 막고 싶으면 `sealed` 예약어 사용
    
    ```csharp
    sealed class Pen
    {
    }
    
    public lcass EleticPen : Pen // 컴파일 오류 발생
    {
    }
    ```
    
- 단일 상속 지원

## 형변환

- 암시적 형변환
    - 특수화 타입의 변수에서 일반화된 타입의 변수로 값이 대입되는 경우
- 명시적 형변환
    - 일반화 타입의 변수에서 특수화된 타입의 변수로 값이 대입되는 경우
- 형변환 잘 못 했을 시 컴파일은 되지만 실행시 오류 발생
    - 개발자가 의도적으로 원하는 경우도 있기 때문에
- 자식 클래스의 인스턴스를 부모 객체의 배열에 담을 수 있음 → 암시적 형변환
- `is` `as` 연산자
    - 형변환 오류 컴파일 단계 아닌 실행 단계에서 발생 → 닷넷 프로그램에서 오류 발생하는 것은 내부적으로 부하가 크다
    - `is` : 형변환의 가능성 여부를 불린형으로 반환
        
        → 값 형식에도 사용할 수 있음
        
    - `as` : 형변환 가능시 지정된 타입의 인스턴스 값 반환/ 형변화 불가능시 `null` 반환
        
        → 참조형 변수에 대해서만 적용 할 수 있고 참조형 타입으로의 체크만 가능
        

## System.Object : 모든 타입의 조상

- C# 컴파일러는 기본적으로 `object`라는 타입에서 상속받는다고 가정하고 자동으로 코드를 생성
- `object` 그 자체가 참조형임에도 값 형식의 부모 타입이기도 함
    - 모든 값 형식을 `System.ValueType` 타입에서 상속받게 하고 이는 `System.Object`를 상속 받음
- `ToString`
- `GetType`
- `Equals`
    - `System.ValueType`에서 하위 클래스는 이를 재정의해서 사용하기에 사용 방법이 다름
- `GetHashCode`
    - 특정 인스턴스를 고유하게 식별할 수 있는 4바이트 `int` 값을 반환

## System.Array : 모든 배열의 조상

- 배열은 모두 `Array` 타입을 조상으로 사용
- C# 컴파일러는 자동적으로`int[]` 타입을 `Array` 타입으로부터 상속받는 것으로 처리
- 배열이`System.Array`로부터 상속받은 참조형 타입

## this

- 객체는 외부에서 자신을 식별할 수 있는 `this`예약어
- 생성자 오버로딩에서 사용
    
    ```csharp
    public Book(stirng title) : this(title, 0)
    {
    }
    
    ```
    
- 인스턴스 멤버와 정적 멤버의 차이 → `this`예약어 사용할수 있냐 없냐로 나뉨
- 모든 인스턴스 메서드는 인자를 무조건 1개 이상 더 받게 되어 있음
    
    → c# 컴파일러는 메서드 호출 시 `this`를 인스턴스 메서드의 첫번째 인자로 넘겨줌
    
    - 내부에서 인스턴스 멤버에 접근할 일이 없다면 정적 메서드로 명시하는 것이 성능상 유리

## base

- `this` : 클래스 인스턴스 자체를 가리킴
- `base` : 부모 클래스를 가리킴
- `base`예약어를 이용해 어떤 생성자를 어떤 값으로 호출해야 할지 명시 가능
    
    ```csharp
    class EBook : Book
    {
    	public EBook() : base(0)
    	{
    	}
    }
    ```
    

## 다형성

- 메서드 오버라이드
- 일반 메서드를 가상 메서드로 바꾸려면 `virtual`예약어를 부모 클래스 단계에 명시
    
    ```csharp
    class Mammal
    {
    	virtual public void Move()
    	{
    		Console.Write("이동한다. ");
    	}
    }
    
    class Lion : Mannal 
    {
    	override public void Move()
    	{
    		Console.Write("네 발로 움직인다. ");
    	}
    }
    ```
    
    - `static`, `abstract`, `private`, `orverrid` 예약어와 함께 사용 X
    - 파생 클래스에서 구현을 선택하는 것
        - `new` : 기본 클래스의 메서드 숨기고 독립적 정의
        - `override` : 기본 메서드 대신해 확장
- `override/virtual` 예약어 사용해 메서드 오버라이드(다형성)을 적용
    - 자식클래스에서 동일한 이름을 사용하기 위해 반드시 예약어 사용 X
    - `override/virtual` 사용 : 메서드 오버라이드
    - `new`사용 : 단순히 자식 클래스에서 동일한 이름의 메서드 필요
- 부모 클래스를 만들었던 개발자가 자식 클래스에서 `base`를 호출하거나 호출하지 못하게 강제할 수 있는 방법은 없다.

## 오버로드

- 메서드 오버로드 : 매개변수의 수, 개별 매개변수 타입만 다르게
- 연산자 오버로드 : 연산자 역시 타입별로 재정의 가능
    
    ```csharp
    public static 타입 operator 연산자(타입1 변수명1, 타입2 변수명2)
    {
    	// [타입]을 반환하는 코드
    }
    ```
    
    →  C#에서는 연산자와 메서드 간의 구분이 없음
    
    - 논리 연산, 기타 연산은 오버로드 X, 나머지는 가능

## 클래스 확장

- 중첩 클래스 : 클래스 내부에 또 다른 클래스 재정의
    
    → 중첩 클래스의 경우 접근 제한자가 생략되면 다른 멤버와 마찬가지로 `private`이 지정되어 외부에서 인스턴스 직접 생성하는 것 불가능
    
- 추상 클래스
    - 추상 클래스 : 부모 클래스의 인스턴스르 생성하지 못하게 하면서 특정 메서드에 대해 자식들이 반드시 재정의 하도록 강제
    - 추상 메서드 : 코드 없는 가상 메서드로 접근 제한자로 `private`을 지정할 수 없음
        
        → 가상 메서드에 속하기에 자식 클래스에서 `override`예약어를 사용해 재정의
        
    - `new`를 사용해 인스턴스로 만들수 없음
    - 추상 메서드를 가질 있음
- 델리게이트
    - 메서드를 가리킬 수 있는 타입
    
    ```csharp
    접근제한자 delegate 대상_메서드의_반환타입 식별자(대상_메서드의_매개변수)
    ```
    
    - 메서드를 호출하는 역할을 하고 타입임!!
    - 메서드의 반환값으로 델리게이트 사용 가능
    - 메서드의 인자로 델리게이트 전달 가능
    - 클래스의 멤버로 델리케이트 정의 가능
    - 클래스 내부에서 델리케이트를 정의했다면 중첩 클래스일뿐 그 이상도 그 이하도 아님
- 콜백 메서드
    - 콜백 메서드는 메서드를 사용하는 전형적인 패턴의 하나
    - 메서드를 호출하는 것이기에 실제 필요한 것은 타입이 아닌 하나의 메서드
        - 타입 자체에 전달해 실수 여지를 남기기보다는 메서드에 대한 델리케이트만 전달해 문제를 해결하자
- 인터페이스
    - 계약이라고 정의되며, 구현없이 메서드 선언만 포함된 클래스 문법과 비슷
    
    ```csharp
    접근_제한자 interface 인터페이스_명
    {
    	//메서드
    }
    ```
    
    → 인터페이스는 메서드 선언은 0개 이상 포함 가능
    
    - 인터페이스는 클래스가 아니기 때문에 다중 상속이 허용 된다
    - 인터페이스의 메서드를 자식 클래스에서 구현시 반드시 `pulbic`접근 제한자를 명시
        - 인터페이스 명을 직접 붙이는 경우 `public`접근 제한자 생략 가능
        
        → 인터페이스 명 붙이는 경우 : 해당 클래스의 멤버로 정의 X = 호출 X
        
    - 인터페이스가 메서드의 묶음이고 C# 프로퍼티가 내부적으로는 메서드를 구현하기에 인터페이스에는 프로퍼티 포함 가능
- 인터페이스와 다형성
    - 인터페이스에 속한 메서드는 모두 가상 메서드에 속함
    - C# 컴파일러가 인터페이스의 메서드를 가상 메서드로 간주 = `virtual`예약어 일부러 지정X
    - 인터페이스 상속받은 자식 클래스 : `override`예약어 지정 X
    
    → `virtual/override`예약어를 막기보다는 굳이 그럴 필요가 없으니 표시하지 못하게 한다
    
- 콜백 구현 = 인터페이스 VS 델리게이트
    - 인터페이스 : 하나의 타입에서 여러개의 메서드 계약 (더 선호)
    - 델리게이트 : 여러개의 메서드로 한번에 호출 (다중 등록 콜백 메서드)
- `IEnumerable`인터페이스
    - 닷넷 프레임워크 내부에서 제공되며 열거자 객체를 반환
    - 열거자 : `IEnumerator`인터페이스를 구현한 객체
    - C#에서 `IEunmerator` 인터페이스를 구현하고 있는 객체에 대해 좀 더 쉽게 열람할 수 있는 열거 문법을 제공 = `foreach`
    - `string` 도 `IEunmerator` 인터페이스를 구현한 사례 중 하나

## 느슨한 결합

- 강력한 결합 : 유연성이 떨어짐
- 느슨한 결합 : 클래스 간에 구현 타입의 정보 없이 인터페이스 등의 방법을 이용해 상호 간에 맺은 계약 만으로 동작하는 것이 의미

## 구조체

- 값 형식에도 `class`처럼 사용자 정의 형식 사용 가능
- 차이점
    - 인스턴스 생성을 `new`로 해도 되고, 안 해도 됨
    - 기본 생성자는 명시적으로 정의 불가
    - 매개변수를 갖는 생성자를 정의해도 기본 생성자가 C# 컴파일러에 의해 자동으로 포함
    - 매개변수를 받는 생성자의 겨우, 반드시 해당 코드 내에서 구조체의 모든 필드에 값을 할당
- 값 형식의 변수를 `new`로 생성하면 해당 변수의 모든 값을 `0`으로 할당하는 것과 동일한 효과
    - 기본형도 동일하게 `new`로 할당하면 `0`으로 할당하는 것과 동일한 효과
- C# 컴파일러는 개발자가 직접 코드 상에서 값을 할당하지 않는 변수를 사용하는 것을 오류라고 판단
    
    ```csharp
    int n;
    Console.WriteLine(n);
    ```
    
    → `n`은 `0`의 값을 갖고 있지만 개발자가 할당한 것이 아니기에 컴파일 오류 
    
- 깊은 복사 : 인스턴스가 가진 메모리 자체가 복사되어 새로운 변수에 대입되는 것
- 얕은 복사 : 참조 형식의 변수가 대입되는 방식 (성능 좋음)
- 구조체 VS 클래스
    - 일반적으로 모든 사용자 정의 타입은 클래스로 구현
    - 깊은/얕은 복사의 차이가 민감한 타입은 선택적 구조체로 구현
    - 참조 형식을 사용하는 경우 GC에 부담이 되는데, 이런 부하를 피해야 하는 경우에 구조체 선택

## ref/out

- CBV : 값에 의한 호출로 변수의 스택 값 복사
- CBR : 참조에 의한 호출로 변수의 힙 값 복사
    
    → `ref`, `out`
    
- `ref` 예약어 사용하는 곳
    - 메서드의 매개변수를 선언할 때 함께 표기
    - 해당 메서드를 호출하는 측에서도 명시
- `ref` 예약어는 구조체를 클래스처럼 얕은 복사로 전달한 것과 동일한 효과
- `ref` 참조형도 사용 가능
    
    → 얕은 복사 시 `stack`에 주소값 공간 무조건 할당하지만 `ref`로 얕은 복사 할 시 `stack`에 주소값 공간 할당 X
    
- `out` VS `ref`
    - `out`으로 지정된 인자에 넘길 변수는 초기화되지 않아도 됌
    - `out`으로 지정된 인자를 받는 메서드는 반드시 변수에 값을 넣어 반환해야 함
    
    → `out`예약어는 `ref`예약어의 기능 가운데 몇 가지를 강제로 제한함으로써 개발자가 좀 더 특별한 용도로 사용하께끔 제공
    
    - `ref` : 메서드를 호출하는 측에서 변수의 값을 초기화 `IN/OUT`
    - `out` : 메서드 측에서 반드시 값을 할당해 반환 `OUT`
- `TryParse`메서드
    - 닷넷 프레임워크는 각 기본 타입에 제공해 변환이 성공했는지 여부를 `bool`로 반환하고 성공해 `result` 변수에 값을 반환

## 열거형

- 값 형식의 하나로 `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong` 만을 상속받아 정의할 수 있는 제항된 사용자 정의 타입
- `enum`은 `ToString` 메서드를 재정의 했고, 그것의 내부 코드에서 숫자값보다는 문자열로 반환하는 역할을 함
- 제약이라면 암시적 형변환이 아닌 명시적 형변환을 통해 순서를 뽑아낼 수 있다
- `[Flag]` 특성 : 특성이라는 구문

## 멤버 유형 확장

- 읽기 전용 필드 : `readonly`
    - 변수를 정의할 때와 생성자 내부를 제외하고는 그 값을 바꾸는 시도를 할 수 없음
    - 불변 타입 객체를 만들때 사용
- 상수
    - 변하지 않는 값인 리터럴을 식별자로 재사용할 수 있게 만들어줌
- `readonly` VS 상수
    - 상수는 static 예약어가 허용되지 않는다.
    - 기본 자료형에서 다룬 형식에서만 상수 정의가 허용된다.
    - 반드시 상수 정의와 함께 값을 대입해야 한다 → 생성자에서 접근 불가
    - 상수는 컴파일 시 해당 소스코드에 값이 직접 치환되는 방식으로 구현
- 이벤트 : `event`
    - 클래스에서 이벤트(콜백)을 제공할때 사용
    - 외부에서 자유롭게 해당 이벤트를 구독하거나 해지하는 것 가능
    - 외부에서 구독/해지는 가능하지만 이벤트 발생은 오직 내부에서 가능
    - 이벤트의 첫 번째 인자로는 이벤트를 발생시킨 타입의 인스턴스
    - 인벤트의 두 번재 인자로는 해당 이벤트에 속한 의미 있는 값이 제공
- 인덱서
    - 클래스가 직관적으로 배열처럼 다뤄질 수 있을 때 사용하기 쉽도록 제공되는 구문