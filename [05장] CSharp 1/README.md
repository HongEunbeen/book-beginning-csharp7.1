# 5장 C# 1.0 완성하기

## 전처리기 지시문

- 특정 소스코드를 상황에 따라 컴파일 과정에서 추가/제거하고 싶을 때 사용

```csharp
#if OUTPUT_LOG
	else
	{
		..
	}
#endif
```

- `#if/#endif` 전처리기 시지문은 `OUTPUT_LOG`전처리기 상수와 함께 사용
- 전처리기를 이용하면 하나의 소스 코드 파일로 여러 가지 상황을 만족하는 프로그램을 만들 수 있음
- `#defind` `#undef` 문은 반드시 소스코드보다 먼저 나타나야 함

## 지역 변수의 유효 범위

- 지역 변수가 정의되면 그것의 유효범위는 변수를 포함하고 있는 블록과 일치
- 중첩된 블록의 경우 부모 블록은 자식 블록의 유효 범위를 포함

## 리터럴에도 적용되는 타입

- 코드 내에서 사용되는 리터럴도 그에 해당하는 타입이 적용

## 특성

- 특성 : 소스코드 파일에만 존재할 뿐, 컴파일러에 의해 빌드된 후 생성되는 EXE/DLL 파일에는 남지 않음
    - 프로그램의 흐름에 직접적인 영향을 끼치지는 않으면서 개발자로 하여금 정보를 남길 수 있는 기능을 제공
    - 특징 스스로는 프로그램의 동작 방식에 관여할 수 없지만 `Reflection`기술과 결합되면 응용 범위가 확장됨
- 닷넷의 어셈블리 파일에는 해당 어셈블리 스스로를 기술하는 메타데이터가 포함
- 사용자 정의 특성
    - `System.Attribute`를 상속받았다는 점을 제외하고 다른 클래스와 차이 없음
    - 관례상 특정 클래스의 이름에 `Attribute`접미사를 붙임
    - 특성을 정의하는 클래스도 `new` 연산자로 인스턴스를 만들 수 있지만 쓰이는 경우 X
    - 특성 클래스를 인스턴스화할수 있는 구문 제공 = 대괄호
        1. `[AuthorAttribute]`
        2. `[Author]` : 접미사 생략
        3. `[Author()]` : `new Author()` 한것 처럼 생성자 표현
- `Flag` 특성
    - `enum` 타입의 동작 방식을 바꾸는 용도로 사용
- 닷넷에서 특성의 용도 제한 가능
    - `System.AttributeUsageAttribute`라는 특성 제공
    - `ArrtibuteTargets`값을 인자로 받는 생성자 = 정의된 값이 바로 적용될 수 있는 대상
        
        → `Assembly`, `Module`, `Class` ,`Struct`, `All`, `Delegate` 등 메서드 내부의 코드를 제외한 C#의 모든 소스코드에 특성을 부여하는 것 가능
        
    - 특성 정의 시 `AttributeUsage` 지정하지 않으면 기본값으로 `AttributeTargets.ALL` 지정

## AssemblyInfo.cs

- `Properties` 폴더 안 `AssemblyInfo.cs` 파일
- C# 코드 파일과 동일하기 때문에 클래스를 내부에 정의해도 되지만 관례상 `AssemblyInfo.cs`파일은 어셈블리 수준에서 적용되는 특성만을 모아두는 용도로 사용
- 여기 정의된 모든 특성은 `AtrributeTargets.Assembly`가 설정된 것
    - 어셈블리에 적용되는 특성은 항상 `[assembly. ]`로 지정
    - 대상이 지정되지 않았다면 특성은 그 다음 나오는 코드를 보고 자동으로 대상을 선택하는데 어셈블리라는 대상 자체를 표현할수 있는 코드가 존재하지 않음
- 생성된 EXE 파일의 속성창을 탐색기에서 보면 개별 특성의 역할을 확인할 수 있음

## 예약어 : 연산 범위 확인 (checked, unchecked)

- `checked` : 산술 연산 코드에 적용시 타입이 지정한 범위를 넘어서는 연산 시도하는 경우 `System.OverflowException` 오류 발생 후 프로그램 실행 종료
    - 명시적인 사용은 개발자로 하여금 실수할 수 있는 여지를 남김
- `unchekced` : 특정 영역의 산술 연산에 대해서는 오버플로나 언더플로가 발생해도 오류 X

## 가변 매개변수 : params

- `params` : 가변 인자로 매개변수를 정의할 때 입력받을 인자의 타입에 해당하는 배열을 선언한 다음 `params`예약어 붙임

```csharp
private static void PrintAll(params object[] values)
{

}
```

## 프로젝트 구성

- 프로젝트는 비주얼 스튜디오의 소스코드 관리를 위해 도입된 개념
- 프로젝트에서 관리하는 모든 정보를 담는 프로젝트 파일이 생성됨
    - 언어마다 확장자 다름
    - C# = `csproj`
    - `xml`로 되어있고 프로젝트에서 소스코드 파일을 추가하거나 프로젝트의 속성 창을 통해 설정을 바꾸는 경우 모드 프로젝트 파일에 보관
- 솔루션
    - 프로젝트보다 큰 단위로 파일안에 확장자가 `sln`인 파일이 들어있음

## 라이브러리

- 라이브러리는 일반적으로 재사용 가능한 단위 의미
- 파일로 저장될 때는 확장자로 DLL 붙음
- 닷넷 프레임워크가 설치되면 일부 라이브러리가 함께 컴퓨터에 설치
    
    → BCL(Base Class Library), FCL(Framwork Class Library) = MS에서 미리 만들어둔 라이브러리
    
- `csc.exe`에 "`/target:library`" 컴파일러 옵션으로 빌드시 라이브러리 생성가능
- DLL을 다른 프로그램 사용하는 것 = 참조
- 사용하는 이유
    - 재사용
    - 컴파일 시간 줄임(수십 개의 파일을 컴파일하기보다 이미 컴파일된 DLL 파일을 참조하는 것)

## 응용 프로그램 구성 파일 : app.config

- 닷넷 응용 프로그램 실행 시 맨처음 CLR 환경 초기화 된 후 개발자가 작성한 코드 실행
    - 이때 CLR 초기화 과정에 값 전달해야 함
    - 하지만 C# 코드는 CLR이 초기화 된 후에야 실행
- `app.config` 파일 제공 :  CLR이 초기화 되기 전 값을 전달하기 위해서
- XML 파일 형식
    - 빌드 전 : `app.config`
    - 빌드 후 : `[프로젝트명].exe.config`

### supprotedRuntime : 닷넷 프레임워크 버전

- 닷넷의 이력이 중요한 이유는 닷넷 응용프로그램을 배포 시 CLR 버전이 맞지 않으면 실행이 안되기 때문
- CLR 버전이 같아도 닷넷 버전에 따라 기능상의 차이있지만 동작은 됌
    
    → 정상적으로 동작되지 않을뿐,,,
    
- `app.config`에서 `supportedRuntime`으로 버전을 볼 수 있음
1. 닷넷 응용 프로그램 실행
2. CLR을 로드
3. 초기화하는 코드 실행 → `[..].exe.config` 있으면 안에 있는 `supportedRuntime` 설정 확인
    1. 현재 시스템에 설치돼 있는 CLR 버전과 `supportedRuntime` 요구 CLR 버전 일치하는 것 로드
4. 닷넷 어셈블리에 포함된 중간언어가 특정 버전의 CLR에 의해 실행

### appSettings : C# 코드에서 읽어들임

- `appSettings`는 CLR보다는 그 위에 실행되는 응용 프로그램에 값을 전달하는 목적
- 주요 목적은 소스코드를 재컴파일하지 않고도 프로그램의 일부 동작을 사용자로 하여금 변경할 수 있게 함

## [Obsolete] : 사용해서는 안되는 기능

- `[Obsolete]` 특성은 더는 사용하지 말아야 될 기능에 부여
- C# 컴파일러는 이 특성이 부여된 기능을 코드에서 사용하면 경고를 발생시키고 Obsolete생성자에 전달된 문자열을 경고 메시지에 포함

## 오류

- 컴파일 시 오류 : 문법 오류로 컴파일러의 오류 메시지 내용에 따라 올바른 문법으로 변경하면 해결
- 실행 시 오류 : 정상적으로 컴파일된 프로그램이지만 실행되는 시점에 오류가 발생하는 것으로 논리 오류등의 원인으로 발생

## 디버그 빌드와 릴리스 빌드

- 디버깅 : 해당 버그를 수정하는 작업, 버그의 원인을 파악하는 것이 핵심
- 디버그 빌드
    - 빌드된 EXE/DLL은 실행 시 CLR에 의해 최적화 과정이 생략되고 개발자가 생성한 코드를 그대로 기계어로 번역
- 릴리스 빌드
    - CLR은 중간 언어를 기계어로 번역할 때 최적화처리를 해 기계어로 만든다
    - 최적화를 허용하는 빌드를 릴리스 빌드
- 전처리 상수 : 디버그 빌드, 릴리스 빌드 시 자동으로 관리됨
    - `TRACE` : 항상 정의
    - `DEBUG` : 디버그 빌드에만 정의
    
    ```csharp
    #if DEBUG
    //
    #endif
    ```
    
- 유사한 기능으로 `Conditional` 특성 : 클래스와 메서드에 적용하고 적용된 클래스와 메서드를 사용하는 코드는 `Conditional` 특성의 생성자로 전달된 전처리 상수가 정의돼 있는 경우에만 EXE/DLL 실행 파일에 포함
    
    ```csharp
    [Conditional("DEBUG")]
    static void OutputText()
    {
    	Console.WriteLine("디버그 빌드");
    }
    ```
    

## 버전 관리

- DLL 파일은 서로 다른 프로세스(EXE)에서 동시에 사용 가능
- 서로 다른 프로그램에서 같은 DLL을 공유할 때 고려하는 것이 바로 버전

## 예외

### 예외 타입

- CLR에 의해 전달되는 예외 = 그 자체도 타입의 인스턴스
- BCL의 하나인 `mscorlib.dll` 파일에 정의되어 있음
- 예외를 만드는 조건
    - 응용프로그램 개발자가 정의하는 예외는 `System.Exception`을 상속받은 `System.ApplicationException`을 상속 받는다
    - 접미사로 `Exception`을 클래스명에 추가한다.
    - CLR에서 미리 정의된 예외는 `System.SystemExcepiton`에서 직접 상속 받는다.
    
    → 강제성이 부여된 것 X . MS에서 내부적으로 CLR의 일부 예외를 `ApplicationException` 타입에서 상속 받아 정의
    
- `System.Exception` : 기본적으로 예외 정보를 구할 수 있는 속성과 메서드를 제공

### 예외 처리기

- 예외가 발생한 경우 CLR의 기본 처리 과정은 예외 메시지를 출력하고 프로그램을 강제 종료
- 강제 종료 방지 위해 개발자가 예외를 발생할 수 있는 코드를 미리 `try/catch`문으로 묶어야 함
    - 개발자는 `try/catch`문을 사용해 예외 처리기를 제공가능
1. CLR에서 예외가 감지된 경우 예외를 유발한 코드에 예외 처리기 존재 검사
2. 예외 처리기 존재 : 처리를 해당 예외 처리기로 넘김
3. 예외 처리기 미존재 : 예외 메시지 출력 후 프로그램 종료 = 처리되지 않은 예외
- 예외가 발생하지 않는다면 `try`블록의 모든 코드 실행
    - 발생한다면 원인이 되는 코드부터 `try`블록의 마지막 코드까지는 실행되지 않음
- `finally`블록 : 자원을 해제하는 코드
- 예외 처리기에서 유일하게 다중 블록 허용 : `catch`블록
    - `catch`블록은 상속 관계를 고려해 예외 타입을 지정해야 함
    - `catch`구문에는 예외 타입뿐 아니라 예외의 인스턴스를 변수로 받아 해당 예외 타입에서 제공되는 모든 멤버에 접근해 정보를 가져올 수 있음

### 호출 스택

- `System.Exception`에 `StackTrace`라는 `string`타입의 멤버 존재
- 스택 트레이스 : 자료구조의 일종인 스택에 저장된 데이터를 추적하는 것으로 프로그램이 실행 될 때 내부적으로는 스택 자료구조가 사용되고 그 안에 메서드의 호출과정과 메서드에 정의된 지역 변수의 데이터가 담긴다
    - 호출 스택을 얻는다 = 스택 트레이스를 얻는다
- CLR은 예외 객체에서 `StackTrace`속성을 통해 호출 스택을 제공하며, 코드에서 예외가 발생한 경우 속성에 값을 담는다
- 정상적인 호출 스택을 구하려면 디버그 모드로 빌드 필수

### 예외 발생

- `throw`예약어 : 예외를 임의로 발생시킴
- `catch`블록 내에 있는 `throw`는 예외 객체 없이 단독으로 사용 가능
    
    → 이렇게 사용하는 것이 좋음
    
- `throw`: 예외를 발생시킨 호출 스택이 모두 출력
- `throw ex`  : 실제 예외가 발생한 호출 스택은 없어지고 `throw ex`코드가 발생한 지점부터의 호출 스택이 남음

### 사용자 정의 예외 타입

- 예외는 타입이기에 원한다면 별도의 클래스를 만드렁 사용할 수 있음
- 사용자 정의 예외는 `System.Exception`을 부모로 두는 것을 권장

### 올바른 예외 처리

- 습관적인 예외 처리가 낳는 부정적인 결과 존재
    - `예외를 먹는 상황`으로 예외 처리로 인해 외부에 아무런 문제 현상이 나타나지 않는 것 의미
    - 예외 처리를 해버리면 결국 오류를 나타내는 반환값을 무시하는 방식과 다를게 없음
- `try/catch` 는 스레드 단위마다 단 한 번만 전역적으로 적용
    - 자원수거가 목적인 `try/finally` 구문은 자유롭게 사용
- `catch`에 정확한 예외 타입을 지정하는 것을 원칙
- 예외가 발생한 경우 → 처리가 매우 무거움
    - 예외 처리를 할 때 CLR 입장에서는 실행해야 할 내부 코드가 늘어남 = 처리 시간 늘어남
    - `Parse`메서드를 `out`인자를 사용해 개선한 `TryParse`메서드를 사용하면 메서드 실행이 성공했는지 여부만 반환되고 예외는 발생 X
- 예외 처리 할 때 규칙
    1. 적어도 공용 메서드에 한해서는 인자갑싱 올바른지 확인 + 올바른 인자 X면 예외 발생
    2. 예외를 범용적으로 `catch`하는 것은 스레드마다 하나만
        
        → 그 외에는 `catch`구문에 반드시 예외 타입을 적용
        
    3. `try/finally` 조합은 언제든 사용 가능
    4. 성능상 문제 발생 → 호출 시 예외가 대량으로 발생하는 메서드가 있다면 예외 처리가 없는 메서드를 함께 제공

## 힙과 스택

- 일반적으로 프로그램 실행 시 프로그램의 코드는 메모리에 적재
- 메모리 상의 코드 → CPU에 의해 하나씩 읽혀지면서 실행
- 이 과정에서 자연스럽게 데이터를 위한 메모리 필요 = 힙과 스택
- 메모리 = 코드 + 데이터(힙과 스택)

## 스택

- 스레드가 생성되면 기본적으로 1MB의 용량으로 스레드마다 할당
- 스택 공간을 활용해 스레드는 메서드의 실행, 해당 메서드로 전달하는 인자, 메서드 내에서 사용되는 지역 변수를 처리
- C# 컴파일러는 지역 변수 할당 공간 4바이트 → 제거하는 명령어 이미 컴파일 과정에 넣어둠
    
    → 결과적으로 지역변수 호출전과 호출 후에 스택에는 변함이 없음
    
- 스택은 그것이 속한 스레드가 메서드 호출을 할 때마다 증가하고 줄어드는 과정을 반복
    
    → 스택 자료구조 하나만으로 인자 전달과 지역변수, 메서드의 실행 흐름을 제어할 수 있음
    

### 스택 오버플로

- 스택은 기본적으로 1MB 공간만 스레드에 할당
- 스택은 메서드 호출이 깊어질수록 그와 함게 스택 사용량도 늘어남
- 메서드 콜스택이 많이 쌓여 1MB 용량 넘는 상황 = 스택 오버플로
- 스택 오버플로 발생시 `try/catch` 유무에 상괂없이 비정상적으로 종료
- 재귀 호출의 단점으로 콜 스택이 과다하게 쌍히는 경우 1MB의 스택 용량을 넘어설 수 있음
- 스택 오버플로 예외 발생
    
    → 콜 스택 정보와 소스코드의 라인 정보가 출력되지 않았음
    
    - 이미 스택 메모리가 모두 소비됐기 때문에 그 상황에서 오류 상황을 알리는 메서드를 호출할 수 없기 때문!!
    - 그 메서드조차도 호출하는 데 스택을 소비하므로 정확한 오류 상황을 보고할 수 없음

## 힙

- 힙의 경우 별도로 명시하지 않는 한 CLR에서는 관리 힙을 가리킴
- CLR의 `GC`가 할당/해제를 관리하기 때문에 붙여진 이름
- C#에서 `new`로 할당되는 모든 참조형 객체는 힙에 할당되고 `new`로 할당된 메모리를 직접적으로 해제하는 명령어는 없음
    
    → `GC`가 알아서 해줌
    
- 힙에 메모리가 누적되어 발생하는 메모리 누수 현상
1. C# 프로그램 코드 실행
2. `new`로 필요한 객체를 힙에 할당
3. 일정 수준의 메모리 할당이 발생하면 `GC` 동작
4. `GC`는 힙에서 객체 중 현재 사용되지 않는 객체는 제거
- `GC` 동작은 프로그램의 다른 동작을 중지시킴
    - 힙을 많이 사용할 수록 `GC`는 더 자주 동작하고 그만큼 프로그램은 빈번하게 실행이 중지되어 심각한 성능 문제를 겪을 수 있음

### 박싱/언박싱

- 값 형식 → 참조 형식 : 박싱
- 참조 형식 → 값 형식 : 언박싱
- `System.ValueType`과 `Object` 타입의 변환이 주기적으로 일어남
- 박싱이 빈번할수록 `GC`는 바빠지고 프로그램의 수행 성능은 떨어진다
    - 박싱을 과다하게 발생시킬 수 있는 코드는 최대한 줄이는 것을 권장
    - `Console.WirteLine`은 다양한 타입의 매개변수를 받도록 정의되어 있어 좋은 사례

### 가비지 수집기

- CLR은 힙은 세대로 나뉘어 관리
- 0세대 : 처음 할당되는 객체
    - 0세대 객체의 총 용량이 일정 크기를 넘어가면 GC는 가비지 수집
    - 가비지 수집 중 사용되고 있는 객체는 1세대로 승격
- 1세대 : 1세대의 객체
    - 1세대의 객체로 승격한 객체의 총 용량이 넘어가면 0세대, 1세대 가비지 수집
    - 가비지 수집 중 사용되고 있는 객체는 2세대 승격
- 2세대 : 2세대 객체
    - 2세대로 승격한 객체도 총 용량이 일정 크기를 넘어가면 0세대, 1세대, 2세대 가비지 수집
    - 가비지 수집 중 사용되고 있는 객체는 승격되는 것이 아닌 2세대의 메모리 공간이 시스템이 허용하는 한 계속 커짐
- 가비지 수집을 진행하면서 힙의 메모리 주소는 계속해서 변경된다
    - 힙 메모리 주소가 수집된 객체의 양만큼 당겨진다.
- 가비지 수집에서 제거되는 객체 : 루트 참조가 없는 것
    - 루트 참조 : 힙 객체를 참조하는 스택 변수, 레지스터, 또 다른 힙 객체 등

### 전체 가비지 수집

- `GC`가 세대를 구분한 이유 : 프로그램 실행 도중 0세대에 할당되고 수집되는 비율이 매우 높다는 통계적인 근거를 기반
- 전체 가비지 수집 :  전체 세대에 걸쳐 가바지 수집을 하는 경우
    - 2세대에서 발생하는 가비지 수집
    - 기존에는 0세대만 빠르게, 1세대까지만 빠르게 진행
- `GC.Collect` 메서드는 가비지 수집을 할 수 있는 세대를 입력받는 메서드 별도로 제공
- MS는 명시적으로 호출해 가비지 수집하는 것을 권장하지 않음

### 대용량 객체 힙

- CLR은 일정 크기(85.000바이트) 이상의 객체는 별도로 대용량 객체 힙(`LOH`)이라는 특별한 힙에 생성
- `LOH`에 할당된 객체는 가비지 수집이 발생해도 메모리 주소가 바뀌지 않음
    
    → 객체를 생성/해제하다 보면 필연적으로 메모리 파편화 현상 발생
    
- 힙에 생성된 객체는 초기부터 2세대에 해당
    
    → `Full GC`가 발생하지 않는 한 `LOH`의 객체는 수집 과정을 거치지 않는다
    

### 자원 해제

- 객체가 소멸되는 시점을 개발자가 알수 없음 = GC가 언제 동작할지는 CLR 내부에 의해 결정
    - 관리 힙에 객체들이 자주 생성되지 않는다면 오랜 시간 동안 객체가 소멸되지 않을 수도 있음
- 닷넷에서도 GC만 믿고 자원 해제를 소홀히 하는 것은 프로그램 운영에 장애를 가져올 수 있음
    - 명시적인 자원 해체가 필요한 클래스를 만드는 개발자의 경우 Close 같은 이름의 멤버 메서드를 함께 제공해야 함
    - `Close`라는 이름이 자원 해제 대표? → 인터페이스 계약을 활용
- MS에서는 자원 해제가 필요하다고 판단되는 모든 개체는 개발자로 하여금 `IDisposable` 인터페이스르 상속받도록 권장
    
    → 이 인터페이스에는 `Dispose` 메서드 단 하나만 정의되어 있음
    
    - 만약 Dispose 전에 예외 발생? → try/finally 이용하기!
- `dispose`와 함께 `try/finally` 사용하는 것 = 관례
- 번거롭다면 `using` 예약어 사용
- `using` 예약어 : 관로 안에서 생성된 객체의 Dispose 메서드를 블록이 끝나는 시점에 자동으로 호출하는 역할
    - `using`을 이용한 코드는 C# 컴파일러에 의해 내부적으로 `try/finally`와 완전히 동일하게 번역
    - `try/finally/Dispose`에 대한 간편 표기법

### 소멸자

- 소멸자 : 객체가 관리 힙에서 제거될 때 호출되는 메서드
- 관리 힙에 할당된 객체의 루트 참조가 없어지면 언젠가는 GC의 실행으로 메모리는 반드시 해제
    
    → 관리 힙인 경우에 한해서만!!
    
- 비관리 메모리에 할당되는 메모리 자원, 또는 윈도우 운영체제와 연동되는 핸들과 같은 자원은 GC의 관리 범위를 벗어나므로 개발자가 직접 해제를 담당해야 함
- `Dispose` 메서드를 호출해줘도 되지만 개발자는 언제든 실수할 수 있기에 좀더 안정적인 클래스 구현을 위해 소멸자가 필요
- 소멸자는 GC가 동작한다면 호출되는것이 보장
    - 클래스를 만든 개발자가 해당 클래스를 사용하는 개발자의 실수를 예상하고 방어적인 차원에서 자원 해제 코드를 넣어 두는 곳이 소멸자
- GC는 소멸자가 구현된 객체를 생성하면 특별히 종료 큐라는 내부 자료구조에 객체를 등록시킴
    - 만약 객체가 소멸자 없는 객체라면 GC에 의해 관리 힙에서 사라짐
    1. 개체에 소멸자가 있다면 소멸자가 있기 때문에 GC는 종료 큐로부터 객체를 꺼내 별도의 `Freachable` 큐에 객체를 보관
    2. `Freachable` 큐에 있는 객체의 소멸자는 CLR에 의해 미리 생성해 둔 스레드가 호출됨
    3. 스레드는 `Freachable` 큐에 항목이 들어오면 해당 객체를 꺼내 소멸자로 실행
    4. GC가 동작하면 객체는 관리 힙에서 제거됨
    
    → 소멸자가 구현된 클래스는 GC에서 더 많은 일을 시킴!
    
- `Dispose`가 호출도니 객체는 GC가 그 객체를 관리 힙에서 제거하는 과정에서 종료 큐에 대한 고려를 하지 않아도 된다
    
    → `GC.SuppressFinalize` 메서드를 제공하기에 이를 `Dispose`와 소멸자로 재정의해서 사용