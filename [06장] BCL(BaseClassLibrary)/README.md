# 6장 BCL(Base Class Library)

- 닷넷 프레임워크에서는 C#과 같은 언어로 만들어진 프로그램에서 OS와 연동할 수 있게 관련 기능 모아 BCL에 담음
    - OS의 소켓, 스레드, 파일, 레지스트리 등 접근하고 싶으면 BCL에서 제공하는 클래스 사용
- BCL은 OS와의 중계역할 + 프로그램의 처리 담당

## 문자열처리

- `≠` : 정적 연산자로 문자열이 같이 않다면 `true`반환
- `==` : 정적 연산자로 문자열이 같다면 `true`반환
    
    → 대소문자 무시 X
    
- 대소문자 구분의 오버로드 버전 제공 메서드
    - `EndsWith`, `IndexOf`, `StartWith` → `StringComparison`열거형 인자로 받을 수 있음
- `Equals`메소드로 바꾸고 `StringComparion.OrdinalIgnoreCase` 사용하면 대소문자 무시해 문자열 비교 가능, 정렬 규칙 변경 가능
- `Format`: 인자를 형식 문자열에 포함된 번화와 맞춰서 치환하는 기능
    - 번호 : 중목 사용 가능, 순서 제약 X, 0부터 시작
        
        ```csharp
        {번호[,정렬][:형식문자열]}
        ```
        
        - 정렬 : 문자열의 최소 너비, 음수면 오른쪽으로 공백, 양수면 왼쪽으로 공백
        - 형식문자열 : 형식문자열 찾아 지정
    - 인자 : `string` 형식일 필요 X, `string` 형식이 아닌 타입의 인스턴스가 인자로 대응시 그것의 `ToString` 메서드를 호출한 결과를 출력
- `System.Text.StringBuilder` : 잦은 메모리 할당과 복사가 없어 성능이 향상됨
    - `string` 타입은 불변객체로 `string`에 대한 모든 변환은 새로운 메모리 할당을 발생 → 연결작업시 시간 오래 걸림
    - `StringBuilder`내부 연산 과정
        - `StringBuilder`는 내부적으로 일정한 양의 메모리를 미리 할당
        - `Append` 메서드에 들어온 인자를 미리 할당한 메모리에 복사
        - 2번 과정을 반복 후 `Append`로 추가된 문자열이 미리 할당한 메모리보다 많아지면 여유분의 메모리 할당
        - `ToSting`메서드 호출 시 연속적으로 연결된 하나의 문자열 반환
- `System.Text.Encoding`
    - `encodng` : 문자가 숫자로 표현되는 것
    - `ASCII` : 7비트 ASCII 문자셋을 위한 인코딩
    - `Default`: 시스템 기본 문자셋을 위한 인코딩
        
        → 한글 윈도우 : `ks_c_5601-1987`
        
        → 영문 윈도우 : `iso-8859-1`
        
    - `Unicode` : 유니코드 문자셋의 `UTF-16` 인코딩
    - `UTF32` : 유니코드 문자셋의 `UTF-32` 인코딩
    - `UTF8` : 유니코드 문자셋의 `UTF-8` 인코딩
        
        → 효율상의 이유로 `UTF8` 많이 사용
        
- `System.Text.RegularExpressions.Regex`
    - 정규표현식 : 문자열 처리에 대한 일반적인 규칙을 표현하는 형식 언어
    - `Replace`: `string` 타입에서도 제공되지만 대소문자가 구분됨

## 직렬화/역직렬화

- 프로그램에서 다뤄지는 모든 데이터는 엄밀히 `byte`데이터
- 파일에 저장되거나 네트워크 선을 타고 이동하는 단위는 결국 `byte`데이터
- 직렬화 : 일련의 바이트 배열로 변환하는 작업
- 역직렬화 : 바이트로부터 원래의 데이터를 복원하는 작업
- 바이트 배열 = 직렬화 수단
    - 데이터를 어떤 것에 보관하고, 그것으로부터 복원만 할 수 있다면 그 모든 작업을 넓은 의미에서 직렬과/역직렬화 한다고 정의

### `System.BitConverter`

- 문자열은 인코딩 방식에 따라 같은 문자열이라도 바이트 배열로의 변환이 달라짐
- 기본 타입은 변환방법이 고정되어 있는데 간단하게 `BitConverter`타입에서 `getByte` 메서드 통해 지원
- `ToString` : 바이트 배열의 값을 16진수 문자열로 표현
- 바이너리 데이터 : 데이터가 바이트로 표현된 것
- 2바이트 이상으로 표현되는 타입은 엔디안 정렬에 주의
    
    → 바이트 순서의 차이
    
    - 리틀 엔디안 : 거꾸로 표현 -  인텔 호환 CPU에서 사용
    - 빅 엔디안 : 차례대로 표현 -  RISC 프로세서 계열에서 사용

### `System.IO.MemoryStream`

- `MemoryStream`은 `Stream` 추상 클래스를 상속받은 타입
- `Stream` : 일련의 바이트를 일관성 있게 다루는 공통 기반 제공
    - 바이트 데이터의 흐름으로 `Stream`에는 데이터를 쓰거나 읽는 작업을 순서대로 하는 것이 기본 정책
- `MemoryStream` : 메모리에 바이트 데이터를 순서대로 읽고 쓰는 작업을 수행하는 클래스
    - 데이터를 메모리에 직렬화/역직렬화 가능
- `position` 멤버의 위치가 읽고 쓰는 작업에 따라 증가해 순서대로 바이트 배열이 다뤄지는 것  = 스트림 특징
    - `wirte`로 바이트 작성 후 읽기위해 `position = 0`으로 이동!
    - 닷넷에서 `Stream`을 상속받은 모든 타입의 기본 동작!

### `System.IO.StreamWriter` / `System.IO.StreamReader`

- `Stream`에 문자열 데이터를 쓰려면 반드시 그 전에 `Encoding` 타입을 이용해 바이트 배열로 변환해야 한다.
    
    → 불편함
    
- MS에서 문자열 데이터를 `Stream`에 쉽게 쓸 수 있는 용도로 `StreamWriter` 타입을 BCL에 제공
- `StreamWiter` : 생성자로 `Stream`과 문자열 인코딩 방식을 받아 내부적으로 속도 향상을 위한 바이트 배열에 들어온 문자열을 보관하고 있다가 일정 크기에 다다르면 한꺼번에 `Stream`으로 쓰기 작업
    
    → `Flush` 메서드는 크기까지 문자열이 체워지지 않아도 현재 보유하고 있는 문자열을 무조건 `Stream`에 쓰는 역할
    
- `StreamReader` : 문자열 읽기 작업으로 두 번째 인자에 지정된 인코딩은 `StreamWriter`에 지정했던 인코딩과 동일해야 함

### `System.IO.BinaryWriter` / `System.IO.BinaryReader`

- `BinaryWriter`/`BinaryReade`r : `Stream`에 2진 데이터를 읽고 쓴는 데 특화된 기능을 제공
- `StreamWriter`와의 차이점은 `MemoryStream`에 저장된 바이트 배열의 내용을 보면 알 수 있음
- 사람이 쉽게 읽을 수 있는 데이터 :  `StreamWiter` / `StreamReader`
- 기록된 데이터의 가독성은 떨어지더라도 규격이 정해진 데이터를 입출력 : `BinaryWriter`/`BinaryReader`

### `System.Runtime.Serialization.Formatters.Binary.BinaryFormatter`

- `BinaryFormatter` : 사용자 정의 클래스 직렬화
    - 사용자 정의 클래스에 `Serializable` 특성
- `Serialize` 메서드 : 직렬화된 데이터 가져옴
- `Desrialize` 메서드 : 역직렬화해 원래의 객체 데이터 복원 가능
- `[Serializable]` : 기본적으로 클래스내의 모든 필드를 대상으로 직렬화
    - `[NonSerialized]` : 직렬화 수행 제외하고픈 필드에 특성 부여
- 단점 : 직렬화 방식이 닷넷 내부에서 고유하게 정의돼 있기 때문에 자바 같은 상이한 플랫폼에서 바이트 배열을 역직렬화해야 원본 데이터를 복원할 수 있는지 알 수 없음 → 상호운영성 떨어짐
- 장점 : 2진 데이터로 직렬화하기에 기타 다른 직렬화 방법에 비해 속도가 빠르고 용량이 적다 → 닷넷 응용 프로그램끼리 데이터 교환시 `BinaryFormatter` 사용하는 것 선호

### `System.Xml.Serialization.XmlSerializer`

- `XmlSerializer` : 클래스의 내용을 문자열로 직렬화
- 클래스에 특성 지정 X
- 제약 사항 존재
    - `public`접근 제한자의 클래스
    - 기본 생성자를 포함하고 있어야 함
    - `public`접근 제한자가 적용된 필드만 직렬화/역직렬화 가능
- 기본적으로 UTF-8 인코딩으로 객체를 문자열로 직렬화
- 장점 : 텍스트를 닷넷 환경이 아닌 다른 플랫폼의 응용 프로그램과 쉽게 주고 받을 수 있음
- 이기종과의 통신 :  `XmlSerializer`
- 닷넷 응용 프로그램 같의 효율적인 통신 : `BinaryFormatting`

### `System.Runtime.Serialization.Json.DataContractJsonSerializer`

- `DataContractJsonSerializer` : `BinaryFormattring` + `XmlSerializer`
    - 자바스크립트의 객체 직렬화 방식을 닷넷에서 동일하게 구현
- `WriteObejct()` : 객체 직렬화
- `ReadObject()` : 객체를 역직렬화해 복원
- 장점 : 길이가 줄어들고 문자열로 되어 있거 가독성이 높고 닷넷 이외의 플렛폼에서도 쉽게 데이터를 주고받아 해석할 수 있음

## 컬렉션

- 모든 C#의 컬렉션은 `IEnumerable` `IEnumerator`를 상속받아 구현
    - `IEnumerable` : 데이터를 리턴하는 `Getter`의 `Getter`로 열거자 `IEnumerator`을 `Get`하는데 필요한 인터페이스 (`foreach`문 돌리기 위해서는 객체 타입이 `IEnumberable`을 상속받아야 함)
    - `IEnumerator` : 데이터를 리턴하는 열거자로 열거자를 구현하는데 필요한 인터페이스

### `System.Collections.ArrayList`

- `obejct` 타입 및 그와 형변환할 수 있는 모든 타입을 인자로 받아 컬렉션에 추가/삭제/변경/조회 할 수 있는 기능을 구현한 타입
- 장점 : `object`를 인자로 갖기에 닷넷의 모든 타입을 담을 수 있음
- 담점 : 박싱이 발생
    
    → `System.ValueType`을 상속받는 값 형식을 위한 컬렉션용으로 적당하지 않음 
    
    → 제네릭이 적용된 `List<T>` 타입 사용하자~~
    
- 정렬 가능하지만 요소가 모두 같은 타입이어야 가능
    
    → `ArgumentExcetion`
    
- 사용자 정의 정렬  : `IComparable` 인터페이스를 구현한 타입의 객체를 `Sort` 메서드 2번째 인자로 전달
    - Sort() : 기본적으로 요소의 객체가 Icomparable 인터페이스 가지는지 확인 후 있으면 CompareTo 메서드 호출해 결과로 정렬작업 수행

### `System.Collections.Hashtable`

- 값뿐만 아니라 해시에 사용되는 키가 추가되어 빠른 검색 속도를 자랑
- 검색속도의 중요도에 따라 `ArrayList` vs `Hashtable` 결정
    - 컬렉션에 담긴 항목 수 많은 경우 : `Hashtable` → 값을 해시해 값을 검색하는 과정 없이 곧바로 저장된 값의 위치 알 수 있음
    - 크기가 작을 경우 : `ArrayList`
- 주의할 점
    - 키 값이 중복되는 경우 `Add`메서드 `ArgumentExceptino`
    - 키 값도 내부적으로 보관하고 있어 메모리 낭비
    - 키와 값이 모두 `object` 타입 → 박싱 문제

### `System.Collections.SortedLsit`

- `SortedList`의 키는 그 자체가 정렬되어 값의 순서에 영향
- `Sort` 메서드 호출할 필요 없이 `Add` 메서드에 요소가 삽입될 때마다 바로 정렬
- 키 값이 중복되는 경우 예외 발생

## 파일

### `System.IO.FileStream`

- `FileStream`은 파일을 다루기 위한 BCL의 가장 기본적인 타입
    - `MemoryStream` : 메모리에 할당한 바이트 배열을 대상으로 읽기쓰기 작업
    - `FileStream` : 디스크의 파일을 대상으로 읽기 쓰기 작업
- 기본 경로 : EXE 폴더와 같음
    - `Environment.CurrentDirectory`의 값
    - 변경시 반드시 존재하는 디렉터리 경로를 지정

### `System.IO.File` / `System.IO.FileInfo`

- `File` : 자주 사용되는 파일 조작 기능을 담은 정적 클래스
    - 모든 메서드 정적 메서드
- `FileInfo` : `File` 타입의 기능을 인스턴스 멤버로 일부 구현

### [`System.IO.Directory`](http://System.IO.Directory) / `System.IO.DirectoryInfo`

- `Directory` : 윈도우 탐색기와 유사한 프로그램 만들 수 있음

### `System.IO.Path`

- `Path.Combine` : 복잡한 경로 연결 문제 해결
    - `params` 유형의 `string` 배열 인자를 취하기에 몆 개의 인자를 전달해도 상환없음 → 그것들을 모아서 적절한 위치에 디렉터리 구분 문자를 넣어 경로 완성

## 스레드

- 스레드 : 명령어를 실행하기 위한 스케줄링 단위로 프로세스 내부에서 생성 가능
- 운영체제에서 멀티 스레딩 지원 : 하나의 프로세스가 여러 개의 스레드 자원 가질 수 있음
    
    → C#은 다중 스레드 응용 프로그램 지원
    
- 주 스레드 : 윈도우는 프로세스를 생성 시 기본적으로 한 개의 스레드 생성
    
    → 주 스레드는 컴파일된 C# 코드르 순착적으로 실행해 나감
    
- 스레드 문맥 : CPU의 명령어 실행과관련된 정보 보관
- OS 스케줄러는 실행돼야 할 적절한 스레드 골라 CPU로 하여금 실행
    - CPU는 현재 실행 중인 스레드 문맥에 CPU 환경 정보 보관
    - OS로부터 할당받은 스레드의 맥맥정도 CPU 내부로 로드해 실행되고 있었던 상태인 것처럼 복원 후 일정 시간 동안 실행
    
    → OS는 프로세스가 바꾸니 것이 아니므로 프로세스의 문맥 정보를 바꾸지는 않음
    

### `System.Threading.Tread`

- `Tread` : 현재 명령어를 실행 중인 스레드 자원에 접근할 수 있는 정적 속성 제공
- `Sleep()` : `Running` 상태인 스레드의 실행을 지정된 밀리초만큼 `ThreadState.WaitSleepJoin` 상태로 변경 → 시간 지난 후 다시 `Running` 상태
- `Start()` : 실행될 명령어의 묶음인 메서드를 `Thread`생성자 전달 후 `Start`메서드 호출해 스레드 시작
    - 최근 다중코어 CPU에서는 실제로 주 스레드와 새로 생성된 스레드의 코드를 동시에 실행 가능
- `Join()` : 새로운 스레드가 배경 스레드임에도 주 스레드가 `Join`메서드 호출 시 배경 스레드의 실행 종료될 때까지 기다림
- 스레드의 종료 = 프로그램의 종료
    - 프로그램은 생성된 모든 스레드가 실행을 종료해야만 프로그램 종료 가능
    - 새롭게 생성된 스레드에서 실행 ing → EXE 프로세스는 해당 스레드 끝날때 까지 종료 X
    - 전경 스레드 : 프로그램의 실행 종료에 영향을 미치는 스레드
    - 배경 스레드 : 실행 종료에 영향을 미치지 않는 스레드
        - 스레드의 종료 여부에 상관없이 `Main`메서드를 실행하는 스레드가 완료되면 프로세스 자체 종료 → 스레드가 CPU에 의해 설택되어 실행될 수 있는 단꼐 까지 시간 전에 `Main` 스레드 종료 시 중단된다
        - `Thread.IsBackground()` 속성 : `true`로 바꾸면 배경 스레드로 전환 가능
- 스레드 단점 : 스레드 사용 X 시 프로그램의 명령 실행할 수 있는 유일한 주 스레드 계산 작업으로 바쁨 + 스레드는 순차적으로만 작업 처리로 계산 작업 완료 전 명령어 실행 불가
    
    → 멀티 스레드 사용하기
    

### `System.Threading.Monitor`

- 스레드는 메모리가 허용하는 한 원하는 만큼 생성 가능
    - 한 개의 스레드에는 1MB의 스택의 용량이 할당됨
- 멀티 스레드 단점 : 스레드는 실행 순서를 장담할 수 없음 + 공유 리소스에 대한 스레드 동기화 필요
- 공유 리소스에 대한 스레드 동기화 방법
    - 공유 자원에 접근하는 앞뒤로 `Monitor` 사용 : `Enter/Exit` 코드 사이에 위치한 모든 코드는 한 순간에 스레드 하나만 진입해 실행 가능 (객체로부터 잠금을 획득)
    - 주의점 : `Enter/Exit` 메서드의 인자로 전달하는 값 = 반드시 참조형 타입의 인스턴스
- `try/finally` + `Monitor.Enter/Exit` = `lock` 예약어
- 스레드에 안전하지 않은 메서드 = 공유 리소스에 대한 스레드 동기화 작업 X
- 스레드에 안전한 메서드 = 공유 리소스에 대한 스레드 동기화 작업
- 모든 메서드 스레드에 안전한 방식 아닌 이유 → 성능상의 문제
    - 대부분의 경우 단일 스레드에서만 접근 = 부수적인 lock 보호 장치 성능상 좋지 않음
    - BCL 모든 타입 사용시 : 인스턴스 멤버에 대해 기본적으로 스레드에 안전 X

### `System.Treading.Interlocked`

- `Interlocked` : 정적 클래스로 다중 스레드에서 공유자원을 사용하는 패턴에 대해서는 명시적인 동기화 작업을 필요 없게 만드는 정적 메서드 제공
    - 정적 메서드로 제공되는 연산의 단위 : 원자적 연산
- 원자적 연산 : 하나의 스레드가 그 연산 상태에 들어갔을 때 연산은 더는 나뉠 수 없는 단일 연산 취급
    
    → 다른 스레드가 중간에 개입 불가
    
- `lock` : 구문의 블록에 있는 모든 연산은 논리적으로 원자적 연산
- `Interlocked` : 몇몇 단순한 유형의 여산에 대해서 복잡한 `lock`대신 대체가능

### `System.Treading.TreadPool`

- `Thread`타입의 생성자에 전달되는 메서드의 코드 유형에 따라 동작 방식 나뉨
    - 상시실행 : 스레드가 생성되면 비교적 오랜 시간 생성돼 있는 유형
    - 일회성의 임시 실행 : 특정 연산만을 수행 후 바로 종료
- 스레드 풀 : 필요할 때마다 스레드를 꺼내 쓰고 필요없어지면 다시 풀에 스레드가 반환되는 기능
- `TreadPool.QueueUserWorkItem()` : 스레드 생성 코드가 생략되고 스레드 생성자에 전되됐던 메서드를 인자로 전달
- 일회성 스레드 필요한 경우 `Tread`객체 생성 VS 스레드 풀 사용
    - ThreadPool이 더 나은 성능
    - `한번 생성된 스레드는 일정 시간동안 재사용 + 스레드는 OS의 커널 자원으로 생성 → 스레드 하나 생성/정료 소비 CPU 큼`

### `System.Threading.EventWaitHandle`

- `EventWaitHandler` : `Monitor`타입처럼 스레드 동기화 수단 중 하나로 스레들 하여금 이벤트를 기다리게 함 + 다른 르세드에서 원하는 이벤트 발생시키는 시나리오 적합
- 이벤트 객체 상태
    - `Signal` : `true`
    - `Non-Signal` : `false`
    
    → 서로 간의 상태 변화 `Set`/`Reset` 메서드로 전환
    
    - 수동 리셋 이벤트 (manual reset) : `Reset`메서드를 호출해야 `Non-Signal`로 돌아옴
        - 명시적인 `Reset`메서드를 호출하기까지 이벤트는 `Signal`상태 지속
    - 자동 리셋 이벤트 (auto reset) : `Set`을 호출한 후 자동으로 `Non-Signal`로 돌아옴
- `WaitOne()` : 스레드가 메서드를 호출하는 이점에 이벤트 객체
    - `Signal` : 메서드에서 바로 제어가 되어 반환
    - `Non-Signal` : 이벤트 객체가 `Signal`상태로 바뀔 때까지 `WaitOne` 메서드 제어 반환 X
        
        → 스레드는 더는 실행되지 못하고 대기 상태로 빠짐
        
- `Thread.Join()` 과 동작 유사하게 구현 가능
    - `EnvetWaitHandle`을 이용하면 `Join`메서드를 호출 할 수 없어 동작의 완료 여부를 알 수 없는 스레드 풀의 단점 보완 가능

### 비동기 호출

- 동기 호출(synchronous call) = 블로킹
- 비동기 호출(asynchronous call) = 논 블로킹 호출
    - 제어를 반환하지 않아 스레드가 아무일도 못하게 되고 CPU가 놀게되는 동기 호출의 단점 해결
    - ex ) `FileState.BeginRead` = 비동기메서드 호출
- 일반적인 목적의 응용 프로그램에서 `QueueUserWorkItem`과 비교했을 때 비동기 호출로 얻는 이득은 크지 않음
    
    → 동시 접속자 수가 많은 게임서버, 웹 서버는 의미
    

### System.Delegate의 비동기 호출

- 일반적 비동기 호출 : 입출력 장치와의 속도 차이에서 오는 비효율적인 스레드 사용 문제 극복
- 닷넷 : 입출력 장치뿐아닌 일반 메서드에 대해서도 비동기 호출 수단 제공 = 델리게이트
    - 메서드를 델리게이트로 연결하는 것 = 비동기 호출을 위한 기반
- 델리게이트의 비동기 호출을 위한 메서드 : `BeginInvoke`, `EndInvoke`
    - 메서드의 수행은 스레드풀의 스레드에서 실행가능
    - 동일한 기능을 `Thread` 타입, `eventWaitHandle` + `TreadPool` 조합 보다 소스코드 간결
- 닷넷 BCL 제공 비동기 호출 = `Deletgate`의 비동기 호출과 유사항 방식으로 구현돼 있음
    - `Begin`/`End` 접두사 메서드 = 비동기 호출을 의미

## 네트워크 통신

- 네트워크 어댑터 : 컴퓨터 LAN 카드 내장
- IP 주소 : IP 주소는 4바이트로 1바이트씩 점을 이용해 나눠서 표기 0 ~ 255 사이 값
- 도메인 이름 : IP 주소마다 이름을 부여해 인간이 쉽게 기억할 수 있도록
- 도메인 네임 서버 : 도메인 이름과 그에 대응하는 IP 주소 정보를 보과하고 있는 컴퓨터
- 컴퓨터 간의 통신
    - 서로의 주소 아는것
    - 어떤 절차를 거쳐 통신을 주고 받을 것인가에 대한 규칙 = 프로토콜
        
        → TCP/IP
        

### IP : System.Net.IPAddress

- TCP/IP의 Internet Protocol는 4번째 버전에 해당하는 기술 = TPv4
- IPv4 : 통신을 위해 네트워크 어댑터에 고유 주솟값이 부여 = IP 주소
- IPv6 : 2011년 초 모든 IP 주소가 고갈되어 새로운 IP 통신 표준 → 125bit
- 공용 IP : IP 통신에서도 외부에서 접근할 수 있는 IP
    - 인터넷 기관에 공식적으로 등록한 후 사용
    - 인터넷 상에서 해당 IP로 접속해 들어오는 것 가능
- 개인 IP : 공용 IP를 하나 가지고 있으면서 내부적으로 개인 P 부여해 인터넷 사용
    - 인터넷에 직접 노출되지 않는다면 어떤 IP든 컴퓨터에 설정가능
    - 공식적인 인터넷 기관에 사용여부가 등록되지 않음 = 외부에서 해당 IP 로 전급 X
    - 사내 PC간에 서로의 개인 IP 주소로의 통신은 가능
    - 공용 IP가 설정된 라우터를 통해 인터넷에 연결 → 공유 IP가 부여된 기기에 자유롭게 접근 가능
- ISP IP : 가정에서 인터넷 사용시 ISP에서 미리 대량의 공용 IP를 보유해 필요할 떄마다 공용 IP를 대여/회수 시스템
    - 할당된 IP는 공용이지만 컴퓨터를 끄면 해당 IP는 ISP 업체에서 회수
    - 컴퓨터 키면 또 다른 가용한 공용 IP가 할당
- `System.Net.IPAddress` : C#에서 IP가 표현되는 타입
    - Parse 정적 메서드 : 문자열로부터 `IPAddress`인스턴스 변화, 바이트 값을 생성자에 전달
        
        → 올바른 형식이라면 어떤 값이든 `IPAdress.Prase`로 IPv4/IPv6 상관없이 해석 가능
        

### 포트

- 네트워크 통신
    - 서비스를 열고 있는 측 = server
    - 서비스에 접속하는  측 = client
- 서버가 통신 시작 → 클라이언트는 서버를 구분해 접속 시도
    - 서버 = 실제로 TCP/IP 통신을 하는 프로그램 의미 (한 대의 컴퓨터에서 실행되는 서버 프로그램)
    - IP 주소 : 컴퓨터에 장착된 네트워크 어댑터 식별 OK
        
        → OS 상에서 실행중인 프로그램까지는 구분 불가
        
- OS 상에서 실행중인 프로그램을 구분하기 위해 TCP/IP에 포트 개념 추가
- 포트 : 0 ~ 65535 범위에 해당하는 값으로 `ushort`로 표현
    - 포트 도입으로 서버측 프로그램 : IP와 함께 포트 이용해 통신 대기
- 1개의 IP로 65535개의 TCP/IP 응용 프로그램 실행 가능
- 전 세계적으로 합의된 포트
    - 21 : FTP서버
    - 25: SMTF서버
    - 80 : 웹 서버

### EndPoint : System.Net.IPEndPoint

- EndPoint : TCP/IP 통신에서 IP주소 + 포트 가르킴
    - BCL : 단일 클래스로 `IPEndPoint`타입 제공

```csharp
new IPEndPoint(idAddr, 9000);
```

### DNS : System.Net.Dns

- 도메인 네임 : 문자열을 입력받으면 TCP/IP 통신을 하기 위해 반드시 대응되는 IP 주소로 변경
    - BCL : Dns 타입
- `GetHostEntry` : 도메인 이름 입력받으면 시스템에 설정된 도메인 네임버서로 해당 이름의 IP 조회 + `IPHostEntry` 타입 결과로 받음(목록)
- OS 운영체제는 컴퓨터 이름을 자체적인 도메인 이름처럼 해석하는 기능 제공
- DNS 단점 : DNS로부터 IP 주소를 조회 → 속도의 저하 발생
    - 윈도우 OS에서는 내부적으로 조회된 적 있는 도에인명과 IP 주소는 일정시간 동안 저장해 동일한 DNS 조회 요청 발생시 서버와의 통신 없이 미리 저장해둔 IP 주소를 곧바로 반환함으로써 속도 향상
- 부하 분산 : 1개의 도메인명에 N개의 IP가 묵인 경우
    - 시스템에 주소가 저장되어 있어 저장된 목록을 비우면(ipconfig) 재 접속시 다른 ip로 접근 가능

### 소켓 : System.Net.Sockets.Socket

- OS는 TCP/IP 통신을 위해 소켓이라는 기능 만듦 
→ 다른 컴퓨터와 통신할 수 있도록 연결해주는 연결부
    - `Client`, `Server` 모두에 소켓이 생성되어 있어야 함
- 닷넷 응용 프로그램도 소켓을 이용해 다른 컴퓨터와 TCP/IP 통신 가능
    - BCL : 소켓은 말 그대로 `Socket`타입
- `Socket` : 모든 인자가 `enum`형식
    - [`SocketType.Stream`](http://SocketType.Stream) + `ProtocolType.Tcp` : 스트림 소켓 or TCP 소켓
    - `SocketType.Dgram` + `ProtocolType.Udp` : 데이터 그램 소켓 or UDP 소켓
    - `IDisposable`을 상속 받음 → 소켓을 생성한 후 필요 없어지면 반드시 자원 해제
- 소켓 통신의 기본 : 접속을 받아들이는 서버 + 그와 연결하는 클라이언트 작성
    - 서버 컴퓨터에는 여러개의 어댑터 - 1:N
    - 어댑터에는 여러 개의 IP - 1:N
    - 서버 소켓 : 컴퓨터에 할당된 IP 주소 중에서 어떤 것과 연결될지 결정(바인딩)
    - 클라이언트 소켓 : 데이터가 전송돼야 할 대상을 지정하기 위해 접점 정보 필요
        
        → 소켓이 특정 IP와 포트에 묶이면 바인딩 송공
        
        → 바인딩 후 다른 다른 소켓에서는 동일한 접점 정보로 바인딩 불가
        
        → 모든 IP에 대해 바인딩 하려면 0.0.0.0 주소 사용 = `IPAdress.Any`
        
        → 자기 IP에 대해 바인딩 하려면 127.0.0.1주소 사용 = `IPAdress.Loopback`
        
- 바인딩
    - 클라이언트 소켓 : 데이터가 전송돼야 할 대상을 지정하기 위해 접점 정보 필요
    - 서버 소켓은 컴퓨터에 할당된 IP 주소 중 어떤 것과 연결될지 결정 하는 과정
    - 소켓이 특정 IP와 포트에 묶이면 바인딩 성공
    - 바인딩 후 다른 소켓에서는 절대로 동일한 접점 정보로 바인딩 불가

### UDP 소켓

- 서버 소켓
    - 서버 포트는 10200으로 대기
    - 데이터 인코딩은 양측 모두 `UTF8`로 정의
    1. UDP 소켓 생성
    2. IP+Port 연결
    3. 클라이언트로부터 데이터를 받는다.
        - `ReceiveFrom(bytes, ref clientEP)`
            
            → 클라이언트가 전송하는 데이터 받음
            
            → 첫번째 인자 : 클라이언트 측에서 전송한 데이터가 담길 버퍼
            
            → 두번째 인자 : `EndPoint`는 `ref`로 전달 (접점 정보는 의미 x, 데이터가 수신되면 해당 데이터를 보낸 측의 접점 정보를 담아 반환하는 역할임)
            
    4. 받은 데이터를 가공해 클라이언트 측에 다시 전송한다
        - `SendTo(snedBytes, clinetEP)`
            
            → 데이터를 가공 후 클라이언트 측에 다시 전송한다.
            
            → 첫번째 인자 : 전송할 데이터를 담은 바이트 배열
            
            → 두번째 인자 : 데이터를 받게 될 UDP 접점 정보
            
- 클라이언트 소켓
    - 서버에 데이터를 전송할 것이므로 별도의 바인딩 과정 X
    - UDP 서버의 접점 정보만 알고 있으면 됨
    - 클라이언트의 수는 늘려도 상관 X → 다중 클라이언트 가능
    1. UDP 소켓 생성
    2. IP+Port 연결
    3. 데이터를 서버로 전송
        - `SendTo(buf, serverDP)`
            
            → 데이터를 서버로 전송
            
            → 첫번째 인자 : 데이터를 UTF-8로 인코딩된 바이트배열
            
            → 두번째 인자 : 데이터를 보낼 UDP 서버의 접점 정보
            
    4. 서버로부터 데이터를 받음
        - `ReceiveFrom(recvBytes, ref serverEP)`
            
            → 서버로부터 데이터를 받음
            
            → 첫번째 인자 : 수신된 데이터를 담게 될 바이트 배열
            
            → 두번째 인자 : 아무값이나 상관 X
            
    5. 받은 데이터 화면에 출력
- 특징
    1. 비연결성
        - 클라이언트 측에서 명시한 Connection 설정 과정 X
    2. 신뢰성 결여
        - 전달된 데이터가 상대방에게 반드시 도착한다는 보장 X
        - 네트워크 장치가 많아질수록 상대방에게 데이터가 전달되지 않을 수도 있음
    3. 순서 없음 
        - 송신자가 보낸 순서와 다르게 데이터 받을 수 있음
        - 네트워크 장치가 많아질수록 순서가 뒤바뀔 가능성 존재
    4. 최대 65,535바이트 한계
        - `SendTo` 메서드 → 전달하는 바이트는 크기를 65535 넘을 수 없음
            - 각종 데이터 패킷의 헤더로 인해 크기는 더 줄어듬
        - UDP 데이터 거쳐가는 네트워크 장비 중 32KB만 제약하는 경우 있음
    5. 파편화
        - 데이터가 분할되어 전송될 수 있는데 이 중 하나라도 패킷이 유실되면 수신 측의 네트워크 장치에서 받은 패킷은 폐기 처분
        - 한 번에 보내는 데이터의 양이 많을수록 데이터 폐기 확률 높아짐
    6. 메시지 중심
        - 바이트 배열을 상대방에게 정상적으로 보내는데 성공한다면 바이트 배열 데이터를 그대로 한번에 받을 수 있음
        - 메시지 경계가 지켜짐

### TCP 소켓

- 서버 소켓
    - 고유한 접점으로 바인딩 시 같은 OS에서 실행되는 어떠한 프로세스도 동일한 정보로 소켓 바인딩 불가
    - TCP 서버용 소켓 인스턴스는 클라이언트와 직접 통신할 수 없고 오직 새로운 연결을 맺는 역할만 함
    - 클라이언트와의 직접적인 통신은 서버 소켓의 `Accept`에서 반환된 소켓 인스턴스로만 할 수 있음
    - 다중 클라이언트 연결 허용
    1. TCP 소켓 생성
    2. IP+Port 연결 → 바인딩
    3. 클라이언트로부터 연결을 받을 수 있도록 소켓 상태 전환
        - `srvSoket.Listen(10);`
            
            → `Listen`메서드를 호출하면서 클라이언트로부터의 접속 허용
            
            → 숫자값 : 클라이언트의 접속을 보관할 수 있는 큐의 길이 (10개의 클라이언트 접속을 큐에 보관)
            
    4. Listen 이후 연결된 클라이언트를 하나 꺼내와서 반환 = UDP와의 차이점
        - `Socket clntSocket = srvSocket.Accept();`
            
            → 보관된 클라이언트 연결을 꺼내는 `Accept`메서드
            
            → `clntSocket`으로 클라이언트와의 직접적인 통신 가능
            
    5. 데이터 전송
        - `clntSocket.Receive(recBytes);`
        - `clntSocket.Send(sendBytes);`
            
            → Accept로 반환된 소켓은 클라이언트 소켓과 일대일 대응
            
            → `Send`/`Receive`메서드에서 굳이 접점 정보 알아내기 위한 `IPEndPoint`인자 전달 필요 X
            
            → 그냥 연결을 맺은 상대 측에 데이터 전송/수신하는 역할
            
    6. 서버 소켓 종료
- 클라이언트 소켓
    - UDP와 비교해 `Connect`단계만 추가될 뿐 별반 다르지 않음
    1. TCP  소켓 생성
    2. IP+Port 연결
    3. `Connect`
        - `soket.Connect(serverEP);`
            
            → 클라이언트 측에서 `Connect`를 호출하는 시점에 TCP 서버 소켓은 반드시 `Listen`을 호출한 상태여야 함 → X면 `Connect`호출은 예외를 일으킴
            
    4. 데이터를 서버로 전송
        - `Send(buf)`
            
            → 데이터를 서버로 전송
            
            → 첫번째 인자 : 데이터를 UTF-8로 인코딩된 바이트배열
            
            → 두번째 인자 : 데이터를 보낼 UDP 서버의 접점 정보
            
    5. 서버로부터 데이터를 받음
        - `Receive(recvBytes)`
            
            → 서버로부터 데이터를 받음
            
            → 첫번째 인자 : 수신된 데이터를 담게 될 바이트 배열
            
            → 두번째 인자 : 아무값이나 상관 X
            
    6. 받은 데이터 화면에 출력
- 특징
    1. 연결성
        - 서버 측의 `Listen`/`Accept`와 클라이언트 측의 `Connect`를 이용해 반드시 연결이 이뤄진 다음 통신 가능
    2. 신뢰성
        - 수신 측은 내부적으로 그에 대한 확인(ACK) 신호 보내 송신 측에 전달
        - 데이터가 수신 측에 정상적으로 전달됐는지 확인 가능
        - ACK 신호가 오지 않으면 자동적으로 데이터 재전송함 → 신뢰성 확보
    3. 스트림 중심
        - 메시지 경계를 가지지 않고 전달되는 것 → 스트림 방식
    4. 순서 보장
        - 데이터를 보낸 순서대로 수신측에 전달
- TCP 서버 : 다중 스레드와 비동기 통신
    - TCP 서버 : 소켓 통신에 사용되는 모든 메서드가 기본적으로 동기 호출
        - I/O가 완료될 떄까지 `Send`/`Receive`메서드를 호출한 스레드는 블로킹됨
        - 서버 측에서 `Accept`를 빠르게 처리할 수 없음
    - 서버 소켓이 `Accept`로 반환받은 클라이언트의 처리 → 별도의 스레드에 맡겨서 처리
    - 클라이언트 하나당 스레드 대응 → 구현하기 수비지만 서버의 선은 발휘 X 구조적 결함
        - 하나의 스렉드가 필요로 하는 스택의 메모리 크기 1MB로 동시 접속 클라이언트가 2000개로 제한
        
        → 스레드 문맥 전환 부하 발생
        
    - 비동기 통신 → 소켓 통신은 OS에서 I/O에 속하기에 각각 비동기 메서드가 제공
        
        → 별도의 스레드를 생성하지 않고도 또 다른 클라이언트의 연결을 지연없이 받아서 처리 가능
        
        → 구현이 복잡해지는것이 비동기 호출의 가장 큰 단점
        
- UDP/TCP 통신 예외처리 필수

### HTTP 통신

- 웹 브라우저 : 웹 서버 측에 HTTP 프로토콜을 사용해 데이터를 요청하고 받아와 화면에 보여주는 것
- HTTP 통신은 TCP 서버/클라이언트의 한 사례
    - 웹 서버 = TCP 서버
    - 웹 브라우저 = TCP 클라이언트
- HTTP 서버는 80 포트를 사용하도록 약속
- 웹 서버와 통신하기 위해서는 프로토콜을 알아야함
    - HTTP 프로토콜의 기본 : 요청과 응답
    - 접속한 클라이언트 측에서 먼저 요청 보냄
    - 서버는 요청으로 받은 내용을 분석해 어떤 데이터 넘겨줘야 할지 판단 후 클라이언트 측으로 응답
- 주고 받을 데이터에 대해 HTTP 요청은 서버 측에 자원에 대한 위치를 포함해야 함
    - 2개의 개행 문자를 구분자로 HTTP 헤더/본문
- 웹 브라우저란 단지 사용자가 주소란에 입력한 정보를 기반으로 HTTP 요청을 만들어 TCP 소켓으로 전송하고 응답으로 받은 텍스트 중에서 HTTP 본문에 해당하는 내용을 화면에 출력하는 프로그램

### 그 밖의 프로토콜

- `SMTP` : 메일을 전송
- `POP3` : 메일을 수신
- `FTP` : 파일을 송수신
- `HTTP`

→ 내부적으로 `Send`/`Receive`를 수행하는 부분만 각자 고유한 프로토콜에 맞게 구현

### System.Net.HttpWebRequest/System.Net.WebClient

- `HttpWebRequest` : BCL에서 HTTP 통신을 좀 더 쉽게 하기 위해 제공
    - 내부적으로 TCP 소켓을 생성해 `getResponse`시 지정된 웹 서버로 HTTP 요청/응답 처리
    - HTTP 통신과 관련된 요청/응답 데이터를 적절하게 해석하는 역할
- `WebClient` : `HttpWebRequest`의 기능을 더 추상화
- `UploadFile` : HTTP 통신을 이용해 파일을 업로드
- `DownloadFile` : HTTP 통신을 이용해 파일을 다운로드

## 데이터베이스

### [ADO.NET](http://ADO.NET) 데이터 제공자

- 데이터베이스 프로그램 : TCP 서버로 동작
    - SQL 서버와 통신하기 위해 데이터를 주고 받는 프로토콜 형식 알아야 함 → 전용 lib [ADO.NET](http://ADO.NET) 데이터 제공자 존재
- `System.Data.IDbConnection` : 데이터베이스 서버와의 연결 담당
    - IDisposable 인터페이스 구현
- `System.Data.IDbCommand` : 데이터베이스  서버 측으로 실행된 SQL 문을 전달
    - DB 소유 모든 자원 `SqlCommond`타입을 이용해 조작 가능
    - `ExecuteNonQuery` : 영향받은 ROW의 수 반환
    - `ExecuteScalar` : 1개의 값을 반환하는 쿼리 수행
    - `ExecuteReader` : 다중 레코드를 반
- `System.Data.IDataReader` : 실행된 SQL 문으로부터 반환받은 데이터 열람
    - `reader`는 최초에 아무것도 가리키지 않다가 `Read`를 호출하면서 다음 행의 레코드를 가리킨다
    - 커서 : 내부적으로 레코드를 가리킴 → 전방향 이동한다
    - `Reader`는 `SELECT`결과물을 담고 있는 상태가 아닌 SQL 서버의 데이터 베이스
        
        → 즉, 커서는 SQL 서버의 DB와 연결된 상태
        
    - READ 동작은 반드시 `Connection`객체가 DB 서버에 연결된 상태에서만 가능
    - `DataReader`가 열려있는 동안 SQL 서버와 연결 유지
        
        → 시간이 길수록 SQL 서버의 처리 성능은 낮아진다
        
    - `DataReader`는 `Close`를 하지 않으면 같은 연결 개체에서는 어떤 명령도 실행할 수 없음
- `System.Data.IDbDataParameter` : SQL 문의 인자 값을 보관
    - 쿼리를 만드는 방법 2가지
        - 문자열 연산 - SQL 주입으로 보안 취약, 서버특의 쿼리 수행 저하 단점 존재
            - SQL서버는 수행되는 쿼리 내부적인 컴파일로 실행 계획 생성해 캐쉬
        - 매개변수화된 쿼리 - 실행될 쿼리 문중 변수처럼 사용될 영역을 별도로 구분해 쿼리 전달
- `System.Data.IDbDataAdapter` : `System.Data.DataTable` 개체와 상호작용하는 `Data Adapter`
    - Fill 메서드 : 데이터를 최대한 빨리 읽어내어 `DataSet`개체에 채워 넣고 연결 개체의 사용을 중지

### 데이터 컨테이너

- 데이터 컨테이너 : 데이터를 담고 있는 용도의 타입
    - DB에 정의된 관계형 테이블 구조를 프로그래밍 언어에 정의된 타입에 대응시킨 것 = ORM
    - 기본 내장된 엔티티 프레임워크, 오픈소스 NHibernate 모두 OR 매핑 가능한 Lib
- 일반 닷넷 클래스 데이터 컨테이너
    - 단순한 유형의 닷넷 클래스(POCO) 사용
    - 데이터 컨테이너 타입과 그에 따른 DAC(Data Access Component) 클래스 이용해 DB와 쉽게 연동
    - 응용 프로그램에서 직접 `SqlCommand`를 이용해 DB 조작 X → 데이블 단위로 CRUD 작업 담당 DAC 클래스 만들어 간접적으로 연동해 사용
    - 응용 프로그램과 DB 사이에 층을 두는 것
    - DAC 클래스는 EXE 어셈블리를 분리해 별도의 어셈블리에 담아 다른 컴퓨터에 배포
    
    → 변화에 대한 수용력이 높아진다.
    
- `System.Data.DataSet`범용 데이터 컨테이너
    - DataSet은 MS에서 닷넷 프레임워크에 포함시킨 범용 데이터 컨테이너
        - 닷넷 [`System.Data`](http://System.Data)네임스페이스에 DB의 표현을 그대로 일대일 대응 시킨 클래스
    - `System.Data.DataColnumn` : 칼럼을 지정
    - `DataSet` : `DataTable`의 묶음을 보관하는 컨테이너 역할
    - 장점 : 기존에 데이터 컨테이너로써 POCO를 사용하던 것을 대체할 수 있고 테이블마다 정의해야 했던 POCO 클래스 생략 가능 → DAC 계층과 데이터를 주고받는 데 아무런 문제가 없음
    - 단점 : 메모리 증가 + 형식 안전성 미지원 → 박싱/언박싱 문제 발생
- Typed DataSet
    - Typed DataSet : 형식 안전성이 부여된 `DataSet`으로 형식 안전성에 대해 강력한 형식을 구현한 `DataSet`
    - 프로젝트에 크게 두 가지 변화 존재
        - App.config에 연결 문자열 추가
        - TestDBDataSet.xsd 파일 추가 → VS에서 데이터 소스로 지정된 DB로부터 테이블에 관한 정보 조회해 미리 관련 소스코드까지 생성해둠
    - DAC 클래스를 만들지 않고도 기본 생성된 Typed DataSet만으로도 코드 생성 가능
    - TeatDBDataSet.Desingner.cs
        - 각 테이블에 대한 컬럼 정의가 포함
        - 칼럼별로 공용 속성이 추가
        - 각 테이블에 대해 각각 `DataAdapter`역할하는 타입 추가 → 기본 쿼리문 포함됨
        - `DataAdapter`에는 쿼리 문에 필요한 `SqlParameter`코드 생성되어 있음

### 데이터베이스 트랜잭션

- 트랜젝션 : 다수의 쿼리 실행이 모두 실패하거나 모두 성공하는 논리적 단위
    - 원자성
    - 일관성
    - 고립성
    - 지속성
- `SqlTransaction` : 트랜잭션의 처음과 끝을 소스코드에서 `SqlTransaction`객체를 이용해 지정 가능
    - `Connetion`으로 개체 열기 → `BeginTransaction`으로 트랜젝션 시작 → `SqlCommand`는 트랜잭션 소속 → `Commit`메서드 호출 시 DB에 반영
    - `Commit`메서드 호출 X or `SqlTransaction.Abort`메서드 호출시 `rollback`
    - `SqlCommand.Transaction`속성에 `transaction`변수 대입해야 함
    - 연결 개체가 Open 된 후 메서드 호출해 트랜젝션 시작
- `System.Transactions.TranscationScope` : 트랜잭션에 포함되는 `SqlCommand`마다 일일이 트랜잭션 변수 대입 번거로움 해소 위해 타입 2.0에서 추가됨
    - 직관성이나 기타 부가적인 기능상의 이유로 더 선호되는 추세
    - 연결 개체가 `Open`되기 이전에 미리 생성돼 있어야 함

## 리플렉션

- 닷넷 응용 프로그램의 어셈블리 파일 : 메타데이터 제공
    - BCL에서 제공되는 리플렉션 관련클래스를 이용
    - 메타데이터 정보 얻기
    - 타입 생성
    - 타입에 정의된 메서드 호출
    - 필드/프로퍼티의 값 변경
    - 확장 모듈 구현
- C# 코드가 빌드되어 어셈블리에 포함되는 경우 → 이에 대한 모든 정보 조회 기술 = 리플렉션
- 닷넷 응용 프로그램의 프로세스 구조
    1. OS에서 EXE 프로세스 실행
    2. 내부에서 CLR에 의해 응용프로그램 도메인 (AppDomain) 구획으로 나뉨
    3. AppDomain 만들어지면 내부에 어셈블리들 로드
- 어셈블리, 모듈, 모듈에 구현된 타입 ... 다 열람 가능

### AppDomain과 Assembly

- AppDomain : 애플리케이션이 실행되는 결리된 환경인 애플리케이션 도메인
    
    ![Untitled](6%E1%84%8C%E1%85%A1%E1%86%BC%20BCL(Base%20Class%20Library)%20169f1b1a4ff14a7e84a1ebc174ded6a8/Untitled.png)
    
    - CLR이 구현한 내부적인 격리 공간
    - Process보다 작고 Thread보다 큰 범위의 논리적 파티션
    - AppDomain 내 Thread 중 하나가 비정상 종료 → AppDomain에서 예외처리
    - AppDomain간에는 별도의 통신 방법 설정 X → 서로의 영역 침범 불가
    - AppDomain 불안정하게 종료 → 다른 AppDomain 동작하는 데 영향 X
    - 콘솔 응용 프로그램 → 1개의 공유 AppDomain과 1개의 기본 AppDomain으로 시작
    - 임의로 생성 가능
    - 각 AppDomain은 격리된 상태
        - 클래스의 정적필드가 프로세스마다 공유 X → 정적필드는 AppDomain에 의해 격리되므로 프로세스에 여러개의 AppDomain 존재 시 정적 필드는 AppDomain마다 하나씩 존재
    - AppDomain에 어셈블리 파일 로드시 AppDomain 내려가지 않고서는 해당 어셈블리 해제할 방법 없음
        - 어셈블리 자체적 해제 X → AppDomain 해제하는 경우에만 어셈블리 모두 해제
    - 리플렉션 사용하면 현재 AppDomain + 그 안에 로드된 어셈블리 목록 구할 수 있음
    - `AppDomain.CreateDomain()` : AppDomain 생성하기
    - `AppDomain.CurrentDomain()` : 현재 스레드가 실행 중인 어셈블리가 속한 AppDomain 인스턴스 접근
    - `AppDomain.Unload()` : AppDomain을 해제
    - `AppDomain.CreateInstanceFrom()` : AppDomain 내에 어셈블리 로드하는 방법
        
        → 어셈블리 파일의 경로 + 최소 생성될 객체의 타입명 지정
        
- 기본 응용 프로그램 도메인 : 닷넷 프로그램 실행시 기본적으로 1개의 AppDomain 생성
    - 닷넷 프로세스가 시작하면 생성된 기본 AppDomain으로 프로세스가 종료될 때까지는 해제 불가
        - 한 번 로드된 어셈블리 파일은 해제할 수 없음

### Type과 리플렉션

- 리플렉션을 이요한 타입 접근은 OOP의 캡슐화마저 무시할 수 있음
- 리플렉션을 이용해 타입을 다루는 코드에서 해당 타입이 가진 코드의 멤버를 C# 코드에서 직접 접근 X

### 리플렉션을 이용한 확장 모듈 구현

- 플러그인을 구현한 소프트웨어 동작 방식
    1. EXE 프로그램이 실행되는 경로 아래에 확장 모듈을 담도록 약속된 폴더 있는지 확인
    2. 해당 폴더가 있다면 그 안에 DLL 파일이 있는지 검사 후 로드
    3. DLL이 로드됐으면 사전에 약속된 조건을 만족하는 타입이 있는지 확인
    4. 조건에 부합하는 타입 존재시 생성 후 사전에 약속된 메서드 실행
- 장점 : 해당 코드가 컴파일 시점에 서로에 대한 코드 정보가 없어도 만들 수 있음 = 느슨한 결합
- MEF 프레임워크, Unity 컨테이너 등 유명 라이브러리들도 모두 내부적으로는 리플렉션을 이용해 구현

## 기타

### BinInteger

- `long` : C#에서 표현가능한 최대 정수형 - 6바이트
- `BigInteger` : 닷넷 4.0에 추가된 구조체 타입으로 사용법도 일반적인 `int`/`long`형과 유사
    - 암호화 같은 분야에서는 천문학적인 숫자 필요
- `System.Numerics` 어셈블리 참조 추가
- C# 코드에서 사용되는 숫자형 리털럴로 `BigInteger` 대입 X → 문자열로 초기화
    - `long`형 범위의 숫자라면 `BigInteger`에 그대로 대입 O

### IntPtr

- 정수형 포인터를 의미하는 값 형식의 타입
- 메모리 주솟값을 보관하는 곳
    - 32bit 프로그램 = 4바이트/64bit 프로그램 = 8바이트로 동작
- 윈도우 OS의 핸들값을 보관하는 용도로쓰임
    - 핸들 : 윈도우 OS가 특정 자원에 대한 식별자로서 보관하는 값 → 파일
