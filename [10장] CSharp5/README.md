# 10장 C# 5.0

- C# 5.0에 대응되는 닷넷 프레임워크는 4.5
- 닷넷 프레임워크 4.5/4.6/4.7 → 닷넷 4.0의 교체판
    - 4.5~4.7은 닷넷 4.0이 이미 설치돼 있다면 그와 동일한 폴더에 덮어쓰고,닷넷 4.0이 설치돼 있지 않았다면 새롭게 4.0 폴더에 설치

## 호출자 정보

- 호출자 정보 : 호출하는 측의 정보를 메서드의 인자로 전달하는 것
    - C/C++에서 매크로로 구현 → C#에서는 매크로로 구현된 것 아닌 C#의 특징을 살려 특성과 선택적 매개변수의 조합으로 구현
- `CallerMemberName` : 호출자 정보가 명시된 메서드를 호출한 측의 메서드 이름
- `CallerFilePath` : 호출자 정보가 명시된 메서드를 호출한 측의 소스코드 파일 경로
- `CallerLineNumber` : 호출자 정보가 명시된 메서드를 호출한 측의 소스코드 라인 번호
    
    ```csharp
    static void LogMessage(string text,
    	[CallerMemberName] string memberNAme= "",
    	[CallerFiolePath] string filePath = "",
    	[CallerLineNumber] int lineNumber = 0) 
    { 
    	...
    }
    ```
    
    - 호출자 정보 특성이 명시고니 매개변수 → 선택적 배개변수 형식
- C# 컴파일러에 의해 소스코드 컴파일 시점에 호출자 정보의 특성에 따른 인자값으로 치환

## 비동기 호출

- 동기 vs 비동기식 단일 스레드 vs 비동기식 멀티 스레드
    - 동기 : 계란을 요리한 후 토스트로 요리
    - 비동기식 단일 스레드 : 계란요리를 시작한 후 타이머 설정, 토스토 요리를 시작한 후 타이머 설정 → 다른 일 하고 있다가 타이머 울리면 각각 꺼냄
    - 비동기식 멀티 스레드 : 계란 요리와 토스트 요리를 위해 두 명의 요리사 고용해 지불하고 이 두명의 요리사의 공유 자원을 관리해 줌
    - 작업을 수행하는데는 한 명의 작업자만 필요하고 작업 당 한명의 작업자가 필요하지는 않음
    - 스레드 = 작업자
    - 비동기 = 작업
- `async`와 `await`예약어 → 비동기 호출을 마치 동기 방식처럼 호출하는 코드를 작성할 수 있음
- 동기 → 비동기 바꾸는 방법
    - 동기식 코드에서 일부분을 비동기식 코드로 변환 → 이 방법을 컴파일러가 해주는 것이 `async`/`await`예약어
- `Async`류의 비동기 호출 메서드 + `await`예약어 → C# 컴파일러가 인지 후 그 이후의 코드 어서 비동기 호출 끝난후 실행되도록 코드 변경
    - `await`이후의 코드는 C# 컴파일러에 의해 분리돼 비동기 작업이 완료된 후 별도의 스레드에서 실행된다.
- `async`예약어
    - `await`토큰을 C# 컴파일러에게 식별자로서 인식할 것이냐, 예약어로서 인식할 것이냐를 알려주는 역할만 함
    - `async`예약어를 지정하면 C# 컴파일러는 `await`을 예약어로 취급 후 `await`이 없으면 오류를 발생
    - `async`메서드는 `await`을 1개 이상 가짐
    - 이 자체로 비동기가 아닌 일종의 보조 역할을 하는 컴파일러 지시어임
- `await` 예약어
    - C# 컴파일러에게 중요한 예약어로 `async`가 지정되지 않으면 예약어로 인식되지 않음

### 닷넷 4.5 BCL에 추가된 Async 메서드

- BCL 라이브러리에 제공되면 복잡한 비동기 처리 + `async`/`await` →동기 호출을 하는 것처럼 간단하게 작성할 수 있음
- 동기화 메서드들과 구분해 `await`을 지원하기 위해 `Async`메서드 추가
    - 기본적으로 기존의 `Synchronous메서드명` + `Async`로 사용
    - I/O를 담당하는 `Stream`기반 클래스 등 몇몇 타입에 기존의 `Begin`/`End` 델리게이트로 구현된 비동기 메서드에 대응하는 `Async`메서드 추가됨

### Task, Task<TResult> 타입

- `await`으로 대기할 수 있는 + `Async`메서드의 반환값 →  모두 `Task`또는 `Task<TResult>`유형
- `Task` : 값을 반환하깆 않고 비동기적으로 실행되는 단일 작업
    - `Action` 델리게이트를 인자로 받음
- `Task<TResult>` : `TResult` 형식 매개변수로 재정의된 반환값이 있는 경우 사용
    - `Func` 델리게이트를 인자로 받음
- TPL(병렬 처리 라이브러리) : `Task`, `Task<TResult>`유형으로 스레드 풀을 사용하는 가장 쉬운 방법
    - 스레드 풀 사용 방법
        - TPL
        - 관리 코드내에서 `ThreadPool.QueueUserWorkItem`
        - 콜백 사용
- 기존의 `QueueUserWorkItem`으로 별도의 스레드에서 작업을 수행하던 작업을 Task 타입을 이용해 별도의 스레드에서 작업을 수행하는 방식으로 변경 가능
- `Task`타입 vs ThreadPool의 `QueueUserWorkItem`
    - `Task`타입이 좀 더 세밀하게 제어 가능
        - `QueueUserWorkItem` : 전달된 작업 완료되기 기다리는 코드 → `EventWaitHandle`타입으로 구현
        - `Task` : 전달된 작업 완료되기 기다리는 코드 → `task.Wait()` 
        (`task`의 작업 완료될때 까지 현재 스레드 대기)
    - `Task`는 `Action`타입의 델리게이트를 전달하자마자 객체 생성 필요 없이 곧바로 작업 시작
        
        → `Task`타입은 `TaskFactory`타입의 `Fatory`정적 속성 제공해 `StartNew()`로 단순하게 가능
        
    - `Task<TResult>` : 코드의 실행이 완료된 후 원한다면 반환값 처리 가능
    - `QueueUserWorkItem` : 단순히 코드를 스레드 풀의 자연스레 던져 실행만 가능

→ C# 컴파일러가 `await`예약어를 대상으로 `Task`, `Task<TResult>` 타입을 반환하는 메서드로 제한하는데 이유가 있음 : 이미 이런 타입은 비동기 처리를 위한 내부적인 준비가 되었기에 C# 5.0 컴파일러는 단순히 `await`에 따른 코드를 `Task`에 맡김으로써 비동기 기능을 적은 부담으로 구현 가능

### async 예약어가 적용된 메서드의 반환 타입

- `await`와 함께 사용될 메서드 : `Task` `Task<T>`만 반환 가능
- `async` 예약어가 지정되는 메서드 : `void` `Task` `Task<T>`만 반환 가능
- `async void` : 해당 메서드 내에서 예외가 발생했을 때 처리되지 않은 경우 프로세스 비정상적 종료 → 권장 X
    - 이벤트 처리기의 델리게이트로 사용하는 `EventHandler` 타입때문에 제공
    - 하위 호환성을 지키기 위해
    - 이벤트 처리기를 제외하고는 `async void`는 가능한 한 지양하고 `async Task`, `async Task<T>` 사용 권장

### Async 메서드가 아닌 경우 비동기 처리

- C#의 `await`예약어 → `Task` `Task<TResult>`타입 반환하는 메서드 대상으로 비동기 처리 자동함
- `Async`처리가 적용되지 않은 메서드들에 대해 `Task`를 반환하는 부가 메서드를 만다는 것으로 `await`비동기 처리 가능
    - 기존에는 비동기 처리하려면 별도의 스레드를 이용하거나 델리게이트의 `BeginInvoke` 처리해야 함
- 코드를 단순히 `Task<TResult>`로 바꾸면 `await`를 이용해 쉽게 비동기 호출 적용 가능
    - 이 방법으로 닷넷 BCL에 `Async`메서드로 제공되지 않았던 모든 동기 방식의 메서드를 비동기로 변환 가능

### 비동기 호출의 병렬 처리

- `await + Task` → 병렬로 비동기 호출을 할 수 있음
- 메인 스레드에서 처리 = 3초 + 5초 + = 8초
- 스레드 이용해 처리 = 3초 + 5초 = 5초
    
    → 2개의 작업을 실행한 다음 결과를 받기 위해 `Main`메서드 실행 스레드는 작업 완료순간까지 대기
    
- `Task<TResult>` 이용해 처리  = 3초 + 5초 = 5초
    
    → 2개의 작업을 병렬로 처리하지만 모든 작업이 완료될 때까지 대기
    
    → 2개의 작업을 실행한 다음 결과를 받기 위해 `Main`메서드 실행 스레드는 작업 완료순간까지 대기
    
- `Task<TResult> + await` 처리  = 3초 + 5초
    
    → `Task.WhenaAll + await` 조합으로 `Main`메서드를 수행하는 스레드가 작업이 완료될 때까지 대기하지 않고 곧바로 다음 작업 계속해 수행
    
    → `Task.WhenaAll + await` 조합 이후 코드는 C# 컴파일러에 의해 작업이 완료된 시점에 비동기로 실행되도록 변경
