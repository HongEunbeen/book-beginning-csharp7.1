# 11장 C# 6.0

- C# 6.0에 대응되는 닷넷 프로엠워크의 버전은 4.6

## C# 3.0에 소개된 자동 구현 속성의 초기화 구문

- 자동 구현 속성 초기화 : 자동 구현 속성을 사용한 경우 초기값 부여 불편함을 없애기 위해 제공
    
    ```csharp
    class Person
    {
    	public string Name { get; set;} = "Jame";
    	public string Name_1 {get;} = "Jane";
    }
    ```
    
- 설정자 메서드 없이 읽기 전용 속성 = `public string Name_1 {get;} = "Jane";`
    - 컴파일러는 내부적으로 읽기 전용 속성의 필드로 변경해 컴파일
    - `private readonly string Name_xxx = "Jane":`
    - readonly 예약어 부여로 생성자에서 값을 변경하는 것까지만 허용

## 람다 식을 이용한 메서드, 속성 및 인덱서 정의

- 메서드 단일식 : 메서드가 단일 식으로 이뤄진 경우 = 간단하게 람다 식 이용해 정의 가능
- 속성 : 속성도 내부적으로는 메서드로 구현되기에 람다 식을 속성 정의에도 사용하는 것 가능
    - `public double Angle ⇒ Math.Athn2(y, x);`
    - 주의 : 접근자 메서드만 가진 읽기 전용 속성으로 정의
    
    → 속성 정의에서 람다 식 사용 시 설정자 메서드에 대한 정의는 지원 X
    
- 인덱서 : 인덱서 구분에서 람다 식 정의 가능
    - `get`접근자를 람다 식으로 정의 가능 = 읽기 전용

## using static 구문을 이용한 타입명 생략

- 자주 사용하는 타입의 전체 이름(FQDN)을 `using static`으로 선언
    - 해당 소스코드 파일 범위 내에서 해당 타입의 정적 멤버를 타입명 없이 바로 호출 가능
- `enum`타입의 멤버와 `const`상수 멤버에 대해서도 동일하게 타입명 생략 가능
    - `enum`필드의 내부 구현은 `static`속성을 갖는다
    - `const`필드 내부 구현은 `static`속성을 갖는다
- 화장 메서드의 경우 내부적으로 `static`메서드로 표현되지만 문법적인 모호성 문제로 인해 `using static`적용을 받지 않음
    - 타입명 생략시 컴파일 오류
    - MS에서는 확장 메서드를 본연의 정적 메서드처럼 호출하려고 할 떄는 타입명을 함께 사용해야 하는 것으로 결정함

## null 조건 연산자

- `null`조건 연산자 : `null`확인용 코드를 줄일 수 있는 연산자
    - `Console.Wirte(list?.Count);`
- 단독으로 사용할 수 없고, 반드시 해당 참조형 변수의 멤버를 접근하거나 배열 인덱스와 같은 부가적인 접근을 필요로 함
    - `null` 조건 연산자의 결과값이 `null`을 포함하기에 이를 저장하기 위해서 반드시 `null`값을 처리할 수 있는 타입을 사용해야 함
    - `int count = list?.Count`→ 컴파일 오류
    - `int? count = list?.Count`→ `nullable`형식 사용
- 하나의 함수에서 하나의 참조 변수에 대해 다중으로 사용하는 경우에는 그다지 효율적인 성능의 코드가 나오지 않으므로 사용 주의

## 문자열 내에 식(expression)을 포함

- `string.Format` : `System.String`타입이 불변이라는 점을 감안해 문자열을 직접 연결하는 코드 대신 사용
- 문자열 보간 : `string.Format`의 사용이 빈번하다는 이유로 이에 대한 약식 표현
    - `$"이름 : {Name}, 나이 : {Aget > 19 ? "성년" : "미성년")}"`
    - $ 접두사를 붙인 문자열 내에 중괄호를 사용해 코드 사용
    - 보간 영역에는 식이 허용되므로 메서드 호출, 삼항 연산자 가능
    - 문자열 출력에 대한 형식 문자열도 가능

## nameof 연산자

- `nameof` : 메서드에 전달된 인자값을 이름과 함께 출력
    - 인자 : 식별자라면 뭐든지 가능
    - 반환값 : 식별자 이름의 마지막 이름만 반환

## Dictionary 타입의 인덱스 초기화

- 컬렉션 초기화 : `Dictionary`타입에 대한 초기화도 지원

## 예외 필터

```csharp
try
{
} catch (예외 타입 e) when (조건식)
{
}
```

- 예외 필터 : `catch`에 지정된 예외타입에 속하는 예외가 `try`블록 내에서 발생한 경우, 조건식이 `true`로 평가된 경우에만 해당 예외 처리기가 선택
    - 예외 필터 내 메서드 분리도 가능
- 예외 필터 조건식이 실행되는 시점 = 예외 처리 핸들러가 실행되는 시점 X
    
    → 예외가 발생한 시점의 호출스택이 그대로 보존돼 있어 기존 예외 처리 구조에 영향을 주지 않고도 부가적인 작업을 할 수 있음
    
- 예외 처리 필터는 닷넷의 IL 수준에서 이미 지원 → 기존의 C# 코드로 변경해 처리하기 않고 예외 필터의 IL 코드로 직접 변경
- 예외 필터는 동일한 예외 타입의 `catch`구문을 여러개 두는 것을 허용
    
    → 하지만 동일한 `catch`구문을 여러개 두어도 결국 선택되는 `catch`예외 핸들러는 오직 하나뿐임
    

## catch/finally 블록 내에서 await 사용 가능

- `catch`와 `finally`의 예외 처리 블록 내에서 비동기 호출을 할 수 없었지만 `try`/`catch`/`finally`절에서의 비동기 호을 할 수 있도록 지원

## 컬렉션 초기화 구문에 확장 메서드로 정의한 Add 지원

- 컬렉션 초기화 : 구문이 컴파일되려면 반드시 해당 타입이 `ICollection<T>`인터페이스를 구현해야 한다
    
    → C# 6.0에서는 `ICollection<T>`인터페이스가 없다면 확장 메서드로도 구현돼있는지 다시 한 번 더 찾는 기능 추가
    
- 확장 메서드만 추가하게 되면 `ICollection<T>`를 구현하지 않아도 코드가 정상적으로 컴파일 된다.
    
    ```csharp
    public static class a
    {
    	public static void Add(this NaturalNumber instance, int number)
    	{
    		instance.Numbers.Add(number);
    	}
    }
    ```
